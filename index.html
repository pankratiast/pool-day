<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pool Day</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #0a4a6e; }
        canvas { display: block; cursor: none; }
        #cursor {
            position: fixed;
            width: 24px;
            height: 24px;
            border: 2px solid rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            z-index: 1000;
            box-shadow: 0 0 10px rgba(255,255,255,0.3);
        }
        #cursor.active {
            transform: translate(-50%, -50%) scale(1.5);
            background: rgba(255, 255, 255, 0.2);
        }
        /* POV Slider */
        #pov-control {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 12px;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 20px;
            border-radius: 25px;
            backdrop-filter: blur(10px);
            z-index: 100;
        }
        #pov-control label {
            color: rgba(255, 255, 255, 0.8);
            font-family: system-ui, sans-serif;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        #pov-slider {
            width: 120px;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }
        #pov-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        #pov-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        /* Audio Control */
        #audio-control {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 100;
        }
        #audio-btn {
            width: 44px;
            height: 44px;
            border: none;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s, transform 0.2s;
        }
        #audio-btn:hover {
            background: rgba(0, 0, 0, 0.5);
            transform: scale(1.1);
        }
        #audio-btn svg {
            width: 20px;
            height: 20px;
            fill: rgba(255, 255, 255, 0.8);
        }
        #audio-btn.muted svg.unmuted,
        #audio-btn:not(.muted) svg.muted {
            display: none;
        }
        #audio-btn.muted svg.muted,
        #audio-btn:not(.muted) svg.unmuted {
            display: block;
        }
    </style>
</head>
<body>
    <div id="cursor"></div>
    <div id="pov-control">
        <label>View</label>
        <input type="range" id="pov-slider" min="0" max="100" value="15">
    </div>

    <div id="audio-control">
        <audio id="bg-audio" loop>
            <source src="GORE - あなたの愛への奴隷.mp3" type="audio/mpeg">
        </audio>
        <button id="audio-btn" class="muted" title="Toggle sound">
            <!-- Unmuted icon (speaker with waves) -->
            <svg class="unmuted" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
            </svg>
            <!-- Muted icon (speaker with X) -->
            <svg class="muted" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/>
            </svg>
        </button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // ============================================================
        // CONFIG - Deeper blue like reference image
        // ============================================================
        const CONFIG = {
            // Rich cyan-blue like the reference
            poolColor: new THREE.Color(0x0891B2),
            poolColorDeep: new THREE.Color(0x0369A1),
            poolColorDark: new THREE.Color(0x075985),
            floorColor: new THREE.Color(0x7DD3FC),
            groutColor: new THREE.Color(0x38BDF8),
            waterDepth: 3.0,
            waveSpeed: 0.6,
            waveScale: 0.08,
            causticIntensity: 0.8,  // Brighter caustics
            maxRipples: 20,
            rippleSpeed: 2.5,
            rippleDecay: 1.0,
            rippleStrength: 0.4
        };

        // ============================================================
        // RIPPLES
        // ============================================================
        const ripples = [];
        const MAX_RIPPLES = CONFIG.maxRipples;

        function addRipple(x, z, strength = CONFIG.rippleStrength) {
            ripples.push({ x, z, time: 0, strength });
            if (ripples.length > MAX_RIPPLES) ripples.shift();
        }

        function updateRipples(dt) {
            for (let i = ripples.length - 1; i >= 0; i--) {
                ripples[i].time += dt;
                ripples[i].strength *= (1 - CONFIG.rippleDecay * dt);
                if (ripples[i].strength < 0.005 || ripples[i].time > 5) {
                    ripples.splice(i, 1);
                }
            }
        }

        function getRippleData() {
            const positions = [], params = [];
            for (let i = 0; i < MAX_RIPPLES; i++) {
                if (i < ripples.length) {
                    positions.push(ripples[i].x, ripples[i].z);
                    params.push(ripples[i].time, ripples[i].strength);
                } else {
                    positions.push(0, 0);
                    params.push(-1, 0);
                }
            }
            return { positions, params };
        }

        // ============================================================
        // NOISE GLSL
        // ============================================================
        const NoiseGLSL = `
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

            float snoise(vec3 v) {
                const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i = floor(v + dot(v, C.yyy));
                vec3 x0 = v - i + dot(i, C.xxx);
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min(g.xyz, l.zxy);
                vec3 i2 = max(g.xyz, l.zxy);
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;
                i = mod289(i);
                vec4 p = permute(permute(permute(
                    i.z + vec4(0.0, i1.z, i2.z, 1.0))
                    + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                    + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                float n_ = 0.142857142857;
                vec3 ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_);
                vec4 x = x_ * ns.x + ns.yyyy;
                vec4 y = y_ * ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4(x.xy, y.xy);
                vec4 b1 = vec4(x.zw, y.zw);
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                vec3 p0 = vec3(a0.xy, h.x);
                vec3 p1 = vec3(a0.zw, h.y);
                vec3 p2 = vec3(a1.xy, h.z);
                vec3 p3 = vec3(a1.zw, h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
            }
        `;

        // ============================================================
        // RIPPLE GLSL
        // ============================================================
        const RippleGLSL = `
            #define MAX_RIPPLES 20
            uniform vec2 uRipplePositions[MAX_RIPPLES];
            uniform vec2 uRippleParams[MAX_RIPPLES];
            uniform float uRippleSpeed;

            float calcRipples(vec2 pos) {
                float total = 0.0;
                for (int i = 0; i < MAX_RIPPLES; i++) {
                    float t = uRippleParams[i].x;
                    float s = uRippleParams[i].y;
                    if (t < 0.0) continue;
                    float d = length(pos - uRipplePositions[i]);
                    float r = t * uRippleSpeed;
                    float w = 0.5 + t * 0.15;
                    total += sin((d - r) * 10.0) * exp(-((d-r)*(d-r)) / (w*w)) * s;
                }
                return total;
            }
        `;

        // ============================================================
        // FLOOR SHADER - Enhanced caustics
        // ============================================================
        const floorVS = `
            varying vec2 vUv;
            varying vec3 vWorldPos;
            void main() {
                vUv = uv;
                vec4 wp = modelMatrix * vec4(position, 1.0);
                vWorldPos = wp.xyz;
                gl_Position = projectionMatrix * viewMatrix * wp;
            }
        `;

        const floorFS = `
            uniform float uTime;
            uniform vec3 uPoolColor;
            uniform vec3 uPoolColorDeep;
            uniform vec3 uPoolColorDark;
            uniform vec3 uFloorColor;
            uniform vec3 uGroutColor;
            uniform float uWaterDepth;
            uniform float uCausticIntensity;

            varying vec2 vUv;
            varying vec3 vWorldPos;

            ${NoiseGLSL}
            ${RippleGLSL}

            float tiles(vec2 uv) {
                vec2 t = fract(uv * 1.2);
                float g = 0.02;
                return smoothstep(0.0, g, t.x) * smoothstep(0.0, g, 1.0-t.x) *
                       smoothstep(0.0, g, t.y) * smoothstep(0.0, g, 1.0-t.y);
            }

            float getHeight(vec2 p, float t) {
                float h = snoise(vec3(p * 0.3, t * 0.2)) * 0.6;
                h += snoise(vec3(p * 0.7, t * 0.35)) * 0.3;
                h += snoise(vec3(p * 1.5, t * 0.5)) * 0.15;
                h += calcRipples(p);
                return h * 0.08;
            }

            vec3 getNormal(vec2 p, float t) {
                float e = 0.06;
                float h = getHeight(p, t);
                float hx = getHeight(p + vec2(e, 0.0), t);
                float hz = getHeight(p + vec2(0.0, e), t);
                return normalize(vec3(h - hx, e * 0.5, h - hz));
            }

            // Enhanced caustics - brighter, more defined
            float caustics(vec2 p, float t) {
                float c = 0.0;

                // Multiple scales of caustics
                for (int s = 0; s < 2; s++) {
                    float scale = 1.0 + float(s) * 0.5;
                    vec2 sp = p * scale;

                    for (int i = -1; i <= 1; i++) {
                        for (int j = -1; j <= 1; j++) {
                            vec2 off = vec2(float(i), float(j)) * 0.15;
                            vec2 sampleP = sp + off;
                            vec3 n = getNormal(sampleP / scale, t);
                            vec3 refr = refract(vec3(0.0, -1.0, 0.0), n, 0.75);
                            float h = getHeight(sampleP / scale, t);
                            float dist = (uWaterDepth + h) / max(-refr.y, 0.01);
                            vec2 hit = sampleP + refr.xz * dist * scale;
                            c += exp(-length(hit - p * scale) * 3.5);
                        }
                    }
                }

                // Add bright caustic lines
                vec3 n1 = getNormal(p * 1.2, t * 0.9);
                vec3 n2 = getNormal(p * 0.8, t * 1.1);
                float lines = pow(1.0 - (abs(n1.x) + abs(n1.z)) * 0.7, 4.0);
                lines += pow(1.0 - (abs(n2.x) + abs(n2.z)) * 0.7, 5.0) * 0.5;

                return (c / 18.0) * 2.0 + lines * 0.6;
            }

            void main() {
                vec2 wp = vWorldPos.xz;

                // Subtle tile pattern
                float tile = tiles(wp);
                vec3 base = mix(uGroutColor, uFloorColor, tile * 0.3 + 0.7);

                // Caustics - bright and prominent
                float caust = caustics(wp, uTime);
                caust = pow(max(caust, 0.0), 1.2) * uCausticIntensity;

                // Bright caustic color (white-cyan)
                vec3 causticColor = vec3(0.9, 1.0, 1.0);
                vec3 col = base * 0.4 + caust * causticColor;

                // Deep blue water tint
                col = mix(col, uPoolColor, 0.5);
                col = mix(col, uPoolColorDeep, 0.3);

                // Depth fade at edges
                float edgeDist = min(min(vUv.x, 1.0 - vUv.x), min(vUv.y, 1.0 - vUv.y));
                col = mix(uPoolColorDark, col, smoothstep(0.0, 0.15, edgeDist));

                gl_FragColor = vec4(col, 1.0);
            }
        `;

        // ============================================================
        // WATER SURFACE SHADER
        // ============================================================
        const waterVS = `
            uniform float uTime;
            uniform float uWaveScale;

            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vWorldPos;
            varying float vHeight;

            ${NoiseGLSL}
            ${RippleGLSL}

            void main() {
                vUv = uv;
                vec3 pos = position;

                float wave = snoise(vec3(pos.xz * 0.3, uTime * 0.2)) * 0.6;
                wave += snoise(vec3(pos.xz * 0.7, uTime * 0.35)) * 0.3;
                wave += snoise(vec3(pos.xz * 1.5, uTime * 0.5)) * 0.15;
                wave += calcRipples(pos.xz);

                pos.y += wave * uWaveScale;
                vHeight = wave * uWaveScale;

                float e = 0.2;
                float wx = snoise(vec3((pos.x+e) * 0.3, pos.z * 0.3, uTime * 0.2)) * 0.6 +
                           snoise(vec3((pos.x+e) * 0.7, pos.z * 0.7, uTime * 0.35)) * 0.3 +
                           calcRipples(pos.xz + vec2(e, 0.0));
                float wz = snoise(vec3(pos.x * 0.3, (pos.z+e) * 0.3, uTime * 0.2)) * 0.6 +
                           snoise(vec3(pos.x * 0.7, (pos.z+e) * 0.7, uTime * 0.35)) * 0.3 +
                           calcRipples(pos.xz + vec2(0.0, e));

                vNormal = normalize(vec3((wave - wx) * uWaveScale * 2.0, e, (wave - wz) * uWaveScale * 2.0));

                vec4 wp = modelMatrix * vec4(pos, 1.0);
                vWorldPos = wp.xyz;
                gl_Position = projectionMatrix * viewMatrix * wp;
            }
        `;

        const waterFS = `
            uniform vec3 uPoolColor;
            uniform vec3 uPoolColorDeep;

            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vWorldPos;
            varying float vHeight;

            void main() {
                vec3 view = normalize(cameraPosition - vWorldPos);
                float fresnel = pow(1.0 - max(dot(view, vNormal), 0.0), 2.0);

                vec3 col = mix(uPoolColor, uPoolColorDeep, 0.3 + fresnel * 0.3);

                // Specular
                vec3 light = normalize(vec3(0.2, 1.0, 0.3));
                vec3 h = normalize(light + view);
                float spec = pow(max(dot(vNormal, h), 0.0), 64.0);
                col += spec * vec3(1.0, 0.98, 0.95) * 0.6;

                gl_FragColor = vec4(col, 0.08 + fresnel * 0.12);
            }
        `;

        // ============================================================
        // TOY SHADERS
        // ============================================================
        const toyVS = `
            uniform float uTime;
            uniform vec3 uToyPosition;
            uniform float uToyRotation;
            uniform float uBobPhase;
            uniform float uToyScale;
            uniform vec3 uPartOffset;

            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vWorldPos;
            varying vec3 vLocalPos;

            ${NoiseGLSL}
            ${RippleGLSL}

            void main() {
                vUv = uv;
                vLocalPos = position;

                float waterH = snoise(vec3(uToyPosition.xz * 0.3, uTime * 0.2)) * 0.6;
                waterH += snoise(vec3(uToyPosition.xz * 0.7, uTime * 0.35)) * 0.3;
                waterH += calcRipples(uToyPosition.xz);
                waterH *= 0.08;

                float bob = sin(uTime * 1.3 + uBobPhase) * 0.025;

                vec3 pos = position * uToyScale;

                // Add part offset (for compound toys)
                pos += uPartOffset;

                // Rotate around Y
                float c = cos(uToyRotation);
                float s = sin(uToyRotation);
                pos.xz = vec2(pos.x * c - pos.z * s, pos.x * s + pos.z * c);

                vec3 norm = normal;
                norm.xz = vec2(norm.x * c - norm.z * s, norm.x * s + norm.z * c);
                vNormal = normalize(norm);

                pos += uToyPosition + vec3(0.0, waterH + bob + 0.05, 0.0);

                vWorldPos = pos;
                gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);
            }
        `;

        const toyFS = `
            uniform vec3 uToyColor;
            uniform vec3 uToyColor2;
            uniform float uStripeCount;
            uniform vec3 uToyPosition;
            uniform int uToyType;

            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vWorldPos;
            varying vec3 vLocalPos;

            void main() {
                vec3 view = normalize(cameraPosition - vWorldPos);
                vec3 light = normalize(vec3(0.3, 1.0, 0.2));

                vec3 baseColor = uToyColor;

                // Stripes for rings
                if (uStripeCount > 0.5) {
                    float angle = atan(vLocalPos.z, vLocalPos.x);
                    float stripe = sin(angle * uStripeCount);
                    baseColor = mix(uToyColor, uToyColor2, step(0.0, stripe));
                }

                // Flamingo gradient (type 2)
                if (uToyType == 2) {
                    float grad = smoothstep(-0.5, 0.5, vLocalPos.z);
                    baseColor = mix(uToyColor, uToyColor2, grad);
                }

                // Palm tree base/fronds (type 4)
                if (uToyType == 4) {
                    float grad = smoothstep(-0.3, 0.3, vLocalPos.y);
                    baseColor = mix(uToyColor2, uToyColor, grad);
                }

                // Palm trunk (type 5)
                if (uToyType == 5) {
                    // Subtle wood grain effect
                    float grain = sin(vLocalPos.y * 20.0) * 0.1 + 0.9;
                    baseColor = mix(uToyColor, uToyColor2, grain);
                }

                // Flamingo neck/head (type 6)
                if (uToyType == 6) {
                    baseColor = uToyColor;
                }

                // Beak (type 7) - gradient from black tip to orange
                if (uToyType == 7) {
                    float t = smoothstep(-0.1, 0.1, vLocalPos.z);
                    baseColor = mix(uToyColor, uToyColor2, t);
                }

                float diff = max(dot(vNormal, light), 0.0) * 0.5 + 0.5;

                vec3 h = normalize(light + view);
                float spec = pow(max(dot(vNormal, h), 0.0), 32.0) * 0.5;

                // Plastic-like rim
                float rim = pow(1.0 - max(dot(view, vNormal), 0.0), 2.0) * 0.2;

                vec3 col = baseColor * diff + spec * vec3(1.0) + rim * baseColor;

                gl_FragColor = vec4(col, 1.0);
            }
        `;

        // ============================================================
        // SCENE
        // ============================================================
        let scene, camera, renderer, clock;
        let floor, water;
        let toys = [];
        let raycaster, mouse;
        let cursorEl;
        let lastMousePos = new THREE.Vector2();
        let isMouseDown = false;
        let lastRippleT = 0;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x075985);

            // Camera with adjustable POV
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
            updateCameraPOV(15);  // Default: 1-2 o'clock position

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            clock = new THREE.Clock();
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            cursorEl = document.getElementById('cursor');

            createBackdrop();
            createFloor();
            createWater();
            createToys();

            window.addEventListener('resize', onResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mouseup', onMouseUp);
            window.addEventListener('touchstart', onTouchStart, { passive: false });
            window.addEventListener('touchmove', onTouchMove, { passive: false });
            window.addEventListener('touchend', onTouchEnd);

            // POV slider
            const povSlider = document.getElementById('pov-slider');
            povSlider.addEventListener('input', (e) => {
                updateCameraPOV(parseFloat(e.target.value));
            });

            // Audio control
            const audioBtn = document.getElementById('audio-btn');
            const bgAudio = document.getElementById('bg-audio');
            bgAudio.volume = 0.5;

            audioBtn.addEventListener('click', () => {
                if (audioBtn.classList.contains('muted')) {
                    bgAudio.play();
                    audioBtn.classList.remove('muted');
                } else {
                    bgAudio.pause();
                    audioBtn.classList.add('muted');
                }
            });
        }

        // Update camera position based on POV slider (0 = bird's eye, 100 = more angled)
        function updateCameraPOV(value) {
            const t = value / 100;
            const height = 14 - t * 4;
            const zOffset = t * 8;
            camera.position.set(0, height, zOffset);
            camera.lookAt(0, 0, 0);
        }

        // ============================================================
        // BACKDROP - Rocky cliffs, waterfall, grass (Chao Island style)
        // ============================================================
        const rockVS = `
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vWorldPos;
            void main() {
                vUv = uv;
                vNormal = normalize(normalMatrix * normal);
                vec4 wp = modelMatrix * vec4(position, 1.0);
                vWorldPos = wp.xyz;
                gl_Position = projectionMatrix * viewMatrix * wp;
            }
        `;

        const rockFS = `
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vWorldPos;

            // Simple hash for noise
            float hash(vec2 p) {
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
            }

            float noise(vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                f = f * f * (3.0 - 2.0 * f);
                float a = hash(i);
                float b = hash(i + vec2(1.0, 0.0));
                float c = hash(i + vec2(0.0, 1.0));
                float d = hash(i + vec2(1.0, 1.0));
                return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
            }

            void main() {
                vec3 light = normalize(vec3(0.3, 1.0, 0.2));
                float diff = max(dot(vNormal, light), 0.0) * 0.5 + 0.5;

                // Rocky texture
                float n = noise(vWorldPos.xz * 2.0) * 0.5 + noise(vWorldPos.xy * 4.0) * 0.3;

                // Base rock colors (gray-purple like Chao Island)
                vec3 rockColor1 = vec3(0.45, 0.42, 0.5);
                vec3 rockColor2 = vec3(0.55, 0.52, 0.58);
                vec3 rockColor3 = vec3(0.38, 0.35, 0.42);

                vec3 col = mix(rockColor1, rockColor2, n);
                col = mix(col, rockColor3, noise(vWorldPos.yz * 3.0) * 0.4);

                col *= diff;

                // Darken crevices based on normal
                float crevice = 1.0 - abs(vNormal.y) * 0.3;
                col *= crevice;

                gl_FragColor = vec4(col, 1.0);
            }
        `;

        const waterfallVS = `
            varying vec2 vUv;
            varying vec3 vWorldPos;
            void main() {
                vUv = uv;
                vec4 wp = modelMatrix * vec4(position, 1.0);
                vWorldPos = wp.xyz;
                gl_Position = projectionMatrix * viewMatrix * wp;
            }
        `;

        const waterfallFS = `
            uniform float uTime;
            varying vec2 vUv;
            varying vec3 vWorldPos;

            float hash(vec2 p) {
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
            }

            float noise(vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                f = f * f * (3.0 - 2.0 * f);
                return mix(mix(hash(i), hash(i + vec2(1.0, 0.0)), f.x),
                           mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), f.x), f.y);
            }

            void main() {
                vec2 uv = vUv;

                // Flowing water effect
                float flow = uTime * 2.0;
                float n1 = noise(vec2(uv.x * 8.0, uv.y * 4.0 - flow));
                float n2 = noise(vec2(uv.x * 12.0 + 5.0, uv.y * 6.0 - flow * 1.3));
                float n3 = noise(vec2(uv.x * 20.0, uv.y * 10.0 - flow * 1.8));

                float foam = smoothstep(0.5, 0.8, n1) + smoothstep(0.6, 0.9, n2) * 0.5;
                foam += smoothstep(0.7, 1.0, n3) * 0.3;

                // Water colors
                vec3 waterColor = vec3(0.3, 0.6, 0.8);
                vec3 foamColor = vec3(0.85, 0.95, 1.0);

                vec3 col = mix(waterColor, foamColor, foam * 0.7);

                // Brighter at edges (splash)
                float edge = smoothstep(0.0, 0.15, uv.x) * smoothstep(0.0, 0.15, 1.0 - uv.x);
                col = mix(foamColor, col, edge);

                // Fade at bottom (mist)
                float mist = smoothstep(0.0, 0.3, uv.y);
                col = mix(vec3(0.7, 0.85, 0.95), col, mist);

                gl_FragColor = vec4(col, 0.9);
            }
        `;

        const grassFS = `
            varying vec2 vUv;
            varying vec3 vWorldPos;

            float hash(vec2 p) {
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
            }

            float noise(vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                f = f * f * (3.0 - 2.0 * f);
                return mix(mix(hash(i), hash(i + vec2(1.0, 0.0)), f.x),
                           mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), f.x), f.y);
            }

            void main() {
                float n = noise(vWorldPos.xz * 3.0);
                float n2 = noise(vWorldPos.xz * 8.0);

                vec3 grass1 = vec3(0.2, 0.6, 0.15);
                vec3 grass2 = vec3(0.3, 0.75, 0.2);
                vec3 grass3 = vec3(0.15, 0.5, 0.1);

                vec3 col = mix(grass1, grass2, n);
                col = mix(col, grass3, n2 * 0.3);

                // Slight variation
                col *= 0.9 + n2 * 0.2;

                gl_FragColor = vec4(col, 1.0);
            }
        `;

        function createBackdrop() {
            const rockMat = new THREE.ShaderMaterial({
                vertexShader: rockVS,
                fragmentShader: rockFS
            });

            // Main cliff wall (back)
            const cliffBack = new THREE.BoxGeometry(25, 12, 4);
            const cliffBackMesh = new THREE.Mesh(cliffBack, rockMat);
            cliffBackMesh.position.set(0, 2, -12);
            scene.add(cliffBackMesh);

            // Left cliff
            const cliffLeft = new THREE.BoxGeometry(4, 10, 20);
            const cliffLeftMesh = new THREE.Mesh(cliffLeft, rockMat.clone());
            cliffLeftMesh.position.set(-12, 1, -2);
            scene.add(cliffLeftMesh);

            // Right cliff
            const cliffRight = new THREE.BoxGeometry(4, 8, 18);
            const cliffRightMesh = new THREE.Mesh(cliffRight, rockMat.clone());
            cliffRightMesh.position.set(12, 0, -1);
            scene.add(cliffRightMesh);

            // Stepped rocks (like in Chao Island)
            const stepRock1 = new THREE.BoxGeometry(6, 2, 3);
            const step1 = new THREE.Mesh(stepRock1, rockMat.clone());
            step1.position.set(-4, -1.5, -9);
            scene.add(step1);

            const stepRock2 = new THREE.BoxGeometry(5, 1.5, 2.5);
            const step2 = new THREE.Mesh(stepRock2, rockMat.clone());
            step2.position.set(3, -2, -8);
            scene.add(step2);

            const stepRock3 = new THREE.BoxGeometry(4, 3, 3);
            const step3 = new THREE.Mesh(stepRock3, rockMat.clone());
            step3.position.set(-7, -0.5, -7);
            scene.add(step3);

            // Waterfall
            const waterfallMat = new THREE.ShaderMaterial({
                uniforms: { uTime: { value: 0 } },
                vertexShader: waterfallVS,
                fragmentShader: waterfallFS,
                transparent: true
            });

            const waterfallGeo = new THREE.PlaneGeometry(5, 8);
            const waterfall = new THREE.Mesh(waterfallGeo, waterfallMat);
            waterfall.position.set(-2, 2, -9.8);
            scene.add(waterfall);

            // Store waterfall for animation
            window.waterfallMesh = waterfall;

            // Splash pool at base of waterfall
            const splashGeo = new THREE.CircleGeometry(2, 16);
            splashGeo.rotateX(-Math.PI / 2);
            const splashMat = new THREE.MeshBasicMaterial({
                color: 0x6BBED9,
                transparent: true,
                opacity: 0.6
            });
            const splash = new THREE.Mesh(splashGeo, splashMat);
            splash.position.set(-2, -2.9, -8);
            scene.add(splash);

            // Grass areas
            const grassMat = new THREE.ShaderMaterial({
                vertexShader: rockVS,
                fragmentShader: grassFS
            });

            // Grass surrounding pool
            const grassRight = new THREE.PlaneGeometry(10, 20);
            grassRight.rotateX(-Math.PI / 2);
            const grassRightMesh = new THREE.Mesh(grassRight, grassMat);
            grassRightMesh.position.set(13, -2.95, 0);
            scene.add(grassRightMesh);

            const grassLeft = new THREE.PlaneGeometry(8, 18);
            grassLeft.rotateX(-Math.PI / 2);
            const grassLeftMesh = new THREE.Mesh(grassLeft, grassMat.clone());
            grassLeftMesh.position.set(-13, -2.95, 0);
            scene.add(grassLeftMesh);

            const grassFront = new THREE.PlaneGeometry(30, 8);
            grassFront.rotateX(-Math.PI / 2);
            const grassFrontMesh = new THREE.Mesh(grassFront, grassMat.clone());
            grassFrontMesh.position.set(0, -2.95, 10);
            scene.add(grassFrontMesh);

            // Small decorative rocks
            const smallRockGeo = new THREE.DodecahedronGeometry(0.5, 0);
            for (let i = 0; i < 8; i++) {
                const rock = new THREE.Mesh(smallRockGeo, rockMat.clone());
                const angle = (i / 8) * Math.PI * 2;
                const radius = 7 + Math.random() * 2;
                rock.position.set(
                    Math.cos(angle) * radius,
                    -2.5,
                    Math.sin(angle) * radius - 2
                );
                rock.scale.set(
                    0.5 + Math.random() * 0.8,
                    0.4 + Math.random() * 0.5,
                    0.5 + Math.random() * 0.8
                );
                rock.rotation.set(Math.random(), Math.random(), Math.random());
                scene.add(rock);
            }
        }

        function createRippleUniforms() {
            return {
                uRipplePositions: { value: [] },
                uRippleParams: { value: [] },
                uRippleSpeed: { value: CONFIG.rippleSpeed }
            };
        }

        function createFloor() {
            const geo = new THREE.PlaneGeometry(20, 20);
            geo.rotateX(-Math.PI / 2);

            const mat = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uPoolColor: { value: CONFIG.poolColor },
                    uPoolColorDeep: { value: CONFIG.poolColorDeep },
                    uPoolColorDark: { value: CONFIG.poolColorDark },
                    uFloorColor: { value: CONFIG.floorColor },
                    uGroutColor: { value: CONFIG.groutColor },
                    uWaterDepth: { value: CONFIG.waterDepth },
                    uCausticIntensity: { value: CONFIG.causticIntensity },
                    ...createRippleUniforms()
                },
                vertexShader: floorVS,
                fragmentShader: floorFS
            });

            floor = new THREE.Mesh(geo, mat);
            floor.position.y = -CONFIG.waterDepth;
            scene.add(floor);
        }

        function createWater() {
            const geo = new THREE.PlaneGeometry(20, 20, 80, 80);
            geo.rotateX(-Math.PI / 2);

            const mat = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uWaveScale: { value: CONFIG.waveScale },
                    uPoolColor: { value: CONFIG.poolColor },
                    uPoolColorDeep: { value: CONFIG.poolColorDeep },
                    ...createRippleUniforms()
                },
                vertexShader: waterVS,
                fragmentShader: waterFS,
                transparent: true,
                depthWrite: false
            });

            water = new THREE.Mesh(geo, mat);
            scene.add(water);
        }

        // Track toy groups (compound toys that move together)
        let toyGroups = [];

        function createToys() {
            // Pink ring float - FLAT on water
            const pinkRing = new THREE.TorusGeometry(0.9, 0.3, 16, 32);
            pinkRing.rotateX(Math.PI / 2);
            createToyGroup({
                parts: [{ geometry: pinkRing, offset: [0, 0, 0], color1: 0xFF69B4, color2: 0xFFFFFF, stripes: 8, type: 0 }],
                position: new THREE.Vector3(-3, 0, -1.5),
                radius: 1.2,
                bobPhase: 0
            });

            // Yellow/Orange ring float
            const yellowRing = new THREE.TorusGeometry(0.85, 0.28, 16, 32);
            yellowRing.rotateX(Math.PI / 2);
            createToyGroup({
                parts: [{ geometry: yellowRing, offset: [0, 0, 0], color1: 0xFFD700, color2: 0xFFA500, stripes: 6, type: 0 }],
                position: new THREE.Vector3(3, 0, 1.5),
                radius: 1.1,
                bobPhase: 1.2
            });

            // Teal ring float
            const tealRing = new THREE.TorusGeometry(0.8, 0.26, 16, 32);
            tealRing.rotateX(Math.PI / 2);
            createToyGroup({
                parts: [{ geometry: tealRing, offset: [0, 0, 0], color1: 0x40E0D0, color2: 0xFFFFFF, stripes: 8, type: 0 }],
                position: new THREE.Vector3(0.5, 0, -3),
                radius: 1.0,
                bobPhase: 2.5
            });

            // FLAMINGO - flamboyant with neck and head!
            const flamingoBase = new THREE.TorusGeometry(0.95, 0.32, 16, 32);
            flamingoBase.rotateX(Math.PI / 2);

            // Flamingo body (on top of ring)
            const flamingoBody = new THREE.SphereGeometry(0.4, 16, 12);
            flamingoBody.scale(1.2, 0.6, 1.5);

            // Flamingo neck (curved cylinder - use a bent tube)
            const neckCurve = new THREE.QuadraticBezierCurve3(
                new THREE.Vector3(0, 0, 0.3),
                new THREE.Vector3(0, 0.6, 0.5),
                new THREE.Vector3(0, 0.9, 0.3)
            );
            const flamingoNeck = new THREE.TubeGeometry(neckCurve, 12, 0.08, 8, false);

            // Flamingo head
            const flamingoHead = new THREE.SphereGeometry(0.12, 12, 8);

            // Flamingo beak
            const flamingoBeak = new THREE.ConeGeometry(0.04, 0.15, 8);
            flamingoBeak.rotateX(Math.PI / 2);

            // Flamingo tail feathers
            const flamingoTail = new THREE.ConeGeometry(0.15, 0.4, 8);
            flamingoTail.rotateX(-0.5);

            createToyGroup({
                parts: [
                    { geometry: flamingoBase, offset: [0, 0, 0], color1: 0xFF69B4, color2: 0xFFB6C1, stripes: 0, type: 2 },
                    { geometry: flamingoBody, offset: [0, 0.25, 0], color1: 0xFF1493, color2: 0xFF69B4, stripes: 0, type: 2 },
                    { geometry: flamingoNeck, offset: [0, 0.2, 0], color1: 0xFF1493, color2: 0xFF69B4, stripes: 0, type: 6 },
                    { geometry: flamingoHead, offset: [0, 1.1, 0.3], color1: 0xFF1493, color2: 0xFF69B4, stripes: 0, type: 6 },
                    { geometry: flamingoBeak, offset: [0, 1.05, 0.45], color1: 0x333333, color2: 0xFFAA00, stripes: 0, type: 7 },
                    { geometry: flamingoTail, offset: [0, 0.3, -0.5], color1: 0xFF1493, color2: 0xFFB6C1, stripes: 0, type: 2 }
                ],
                position: new THREE.Vector3(-2.5, 0, 2.5),
                radius: 1.3,
                bobPhase: 3.0
            });

            // PALM TREE - base, trunk, leaves, coconut
            const palmBase = new THREE.TorusGeometry(0.75, 0.28, 16, 32);
            palmBase.rotateX(Math.PI / 2);

            // Palm trunk (tapered, segmented look)
            const palmTrunk = new THREE.CylinderGeometry(0.1, 0.16, 1.4, 12);

            // Palm leaves (multiple fronds)
            const createFrond = (angle) => {
                const frond = new THREE.ConeGeometry(0.12, 0.7, 4);
                frond.rotateX(Math.PI / 2 + 0.8);  // Tilt outward
                frond.rotateY(angle);
                frond.translate(Math.sin(angle) * 0.25, 0, Math.cos(angle) * 0.25);
                return frond;
            };

            // Create 6 fronds around the top
            const fronds = [];
            for (let i = 0; i < 6; i++) {
                fronds.push(createFrond(i * Math.PI / 3));
            }

            // Coconuts
            const coconut1 = new THREE.SphereGeometry(0.1, 8, 6);
            const coconut2 = new THREE.SphereGeometry(0.09, 8, 6);

            const palmParts = [
                { geometry: palmBase, offset: [0, 0, 0], color1: 0x4A90A4, color2: 0x5BA3B8, stripes: 0, type: 4 },
                { geometry: palmTrunk, offset: [0, 0.7, 0], color1: 0x8B4513, color2: 0xA0522D, stripes: 0, type: 5 },
                { geometry: coconut1, offset: [0.15, 1.2, 0.1], color1: 0x654321, color2: 0x8B4513, stripes: 0, type: 5 },
                { geometry: coconut2, offset: [-0.12, 1.15, -0.08], color1: 0x654321, color2: 0x8B4513, stripes: 0, type: 5 }
            ];

            // Add fronds
            fronds.forEach((frond, i) => {
                palmParts.push({
                    geometry: frond,
                    offset: [0, 1.4, 0],
                    color1: 0x228B22,
                    color2: 0x32CD32,
                    stripes: 0,
                    type: 4
                });
            });

            createToyGroup({
                parts: palmParts,
                position: new THREE.Vector3(3, 0, -2.5),
                radius: 1.0,
                bobPhase: 4.0
            });

            // Beach ball
            const ballGeo = new THREE.SphereGeometry(0.4, 24, 16);
            createToyGroup({
                parts: [{ geometry: ballGeo, offset: [0, 0.25, 0], color1: 0xFF4444, color2: 0xFFFFFF, stripes: 6, type: 1 }],
                position: new THREE.Vector3(-0.5, 0, 0.5),
                radius: 0.5,
                bobPhase: 0.5
            });
        }

        function createToyGroup(opts) {
            const group = {
                position: opts.position.clone(),
                radius: opts.radius,
                bobPhase: opts.bobPhase,
                driftSpeed: 0.008 + Math.random() * 0.012,
                driftDir: new THREE.Vector2(Math.random() - 0.5, Math.random() - 0.5).normalize(),
                rotSpeed: (Math.random() - 0.5) * 0.15,
                rotation: Math.random() * Math.PI * 2,
                meshes: []
            };

            opts.parts.forEach(part => {
                const mat = new THREE.ShaderMaterial({
                    uniforms: {
                        uTime: { value: 0 },
                        uToyPosition: { value: group.position },
                        uToyRotation: { value: group.rotation },
                        uPartOffset: { value: new THREE.Vector3(...part.offset) },
                        uToyColor: { value: new THREE.Color(part.color1) },
                        uToyColor2: { value: new THREE.Color(part.color2) },
                        uStripeCount: { value: part.stripes },
                        uToyScale: { value: 1.0 },
                        uToyType: { value: part.type },
                        uBobPhase: { value: opts.bobPhase },
                        ...createRippleUniforms()
                    },
                    vertexShader: toyVS,
                    fragmentShader: toyFS
                });

                const mesh = new THREE.Mesh(part.geometry, mat);
                group.meshes.push(mesh);
                toys.push(mesh);
                scene.add(mesh);
            });

            toyGroups.push(group);
        }

        function screenToWorld(x, y) {
            mouse.x = (x / window.innerWidth) * 2 - 1;
            mouse.y = -(y / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const pt = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, pt);
            return new THREE.Vector2(pt.x, pt.z);
        }

        function onMouseMove(e) {
            cursorEl.style.left = e.clientX + 'px';
            cursorEl.style.top = e.clientY + 'px';

            const wp = screenToWorld(e.clientX, e.clientY);
            if (!wp) return;

            const now = performance.now();
            const dist = wp.distanceTo(lastMousePos);

            if (dist > 0.15 && now - lastRippleT > 25) {
                addRipple(wp.x, wp.y, isMouseDown ? CONFIG.rippleStrength * 1.5 : CONFIG.rippleStrength * 0.3);
                lastRippleT = now;
            }
            lastMousePos.copy(wp);
        }

        function onMouseDown(e) {
            isMouseDown = true;
            cursorEl.classList.add('active');
            const wp = screenToWorld(e.clientX, e.clientY);
            if (wp) {
                addRipple(wp.x, wp.y, CONFIG.rippleStrength * 2);
                pushToys(wp);
            }
        }

        function onMouseUp() {
            isMouseDown = false;
            cursorEl.classList.remove('active');
        }

        function pushToys(wp) {
            toyGroups.forEach(group => {
                const pos = group.position;
                const dist = Math.sqrt((pos.x - wp.x) ** 2 + (pos.z - wp.y) ** 2);
                if (dist < 2.0 && dist > 0.1) {
                    const push = new THREE.Vector2(pos.x - wp.x, pos.z - wp.y).normalize();
                    group.driftDir.lerp(push, 0.5);
                    group.driftDir.normalize();
                    group.driftSpeed = Math.min(group.driftSpeed + 0.03, 0.05);
                    // Gentle spin from push
                    group.rotSpeed += (Math.random() - 0.5) * 0.1;
                }
            });
        }

        function onTouchStart(e) {
            e.preventDefault();
            const t = e.touches[0];
            cursorEl.style.left = t.clientX + 'px';
            cursorEl.style.top = t.clientY + 'px';
            cursorEl.classList.add('active');

            const wp = screenToWorld(t.clientX, t.clientY);
            if (wp) {
                addRipple(wp.x, wp.y, CONFIG.rippleStrength * 2);
                pushToys(wp);
                lastMousePos.copy(wp);
            }
        }

        function onTouchMove(e) {
            e.preventDefault();
            const t = e.touches[0];
            cursorEl.style.left = t.clientX + 'px';
            cursorEl.style.top = t.clientY + 'px';

            const wp = screenToWorld(t.clientX, t.clientY);
            if (!wp) return;

            const now = performance.now();
            if (wp.distanceTo(lastMousePos) > 0.12 && now - lastRippleT > 20) {
                addRipple(wp.x, wp.y, CONFIG.rippleStrength);
                lastRippleT = now;
            }
            lastMousePos.copy(wp);
        }

        function onTouchEnd() {
            cursorEl.classList.remove('active');
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateUniforms() {
            const data = getRippleData();
            const positions = [], params = [];

            for (let i = 0; i < MAX_RIPPLES; i++) {
                positions.push(new THREE.Vector2(data.positions[i * 2], data.positions[i * 2 + 1]));
                params.push(new THREE.Vector2(data.params[i * 2], data.params[i * 2 + 1]));
            }

            floor.material.uniforms.uRipplePositions.value = positions;
            floor.material.uniforms.uRippleParams.value = params;
            water.material.uniforms.uRipplePositions.value = positions;
            water.material.uniforms.uRippleParams.value = params;

            toys.forEach(toy => {
                toy.material.uniforms.uRipplePositions.value = positions;
                toy.material.uniforms.uRippleParams.value = params;
            });
        }

        function updateToys(dt, elapsed) {
            // Update toy groups (compound toys)
            toyGroups.forEach(group => {
                // Apply drift
                group.position.x += group.driftDir.x * group.driftSpeed * dt * 60;
                group.position.z += group.driftDir.y * group.driftSpeed * dt * 60;

                // Slow down
                group.driftSpeed *= 0.995;
                if (group.driftSpeed < 0.005) group.driftSpeed = 0.005;

                // Bounce off edges - gentle
                const bounds = 6;
                if (Math.abs(group.position.x) > bounds) {
                    group.driftDir.x *= -0.5;
                    group.position.x = Math.sign(group.position.x) * bounds;
                    group.driftSpeed *= 0.7;
                }
                if (Math.abs(group.position.z) > bounds) {
                    group.driftDir.y *= -0.5;
                    group.position.z = Math.sign(group.position.z) * bounds;
                    group.driftSpeed *= 0.7;
                }

                // Rotate
                group.rotation += group.rotSpeed * dt;

                // Update all meshes in group
                group.meshes.forEach(mesh => {
                    mesh.material.uniforms.uToyRotation.value = group.rotation;
                    mesh.material.uniforms.uTime.value = elapsed;
                });
            });

            // Collision detection between toy groups - gentle bumping
            for (let i = 0; i < toyGroups.length; i++) {
                for (let j = i + 1; j < toyGroups.length; j++) {
                    const a = toyGroups[i];
                    const b = toyGroups[j];

                    const dx = b.position.x - a.position.x;
                    const dz = b.position.z - a.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    const minDist = a.radius + b.radius;

                    if (dist < minDist && dist > 0.01) {
                        // Collision! Gently push apart
                        const overlap = minDist - dist;
                        const nx = dx / dist;
                        const nz = dz / dist;

                        // Soft separation
                        const pushStrength = overlap * 0.3;
                        a.position.x -= nx * pushStrength;
                        a.position.z -= nz * pushStrength;
                        b.position.x += nx * pushStrength;
                        b.position.z += nz * pushStrength;

                        // Gentle bounce - exchange direction slightly
                        const bounce = 0.15;
                        a.driftDir.x -= nx * bounce;
                        a.driftDir.y -= nz * bounce;
                        b.driftDir.x += nx * bounce;
                        b.driftDir.y += nz * bounce;

                        a.driftDir.normalize();
                        b.driftDir.normalize();

                        // Lose energy on collision (dampen, don't amplify)
                        a.driftSpeed *= 0.85;
                        b.driftSpeed *= 0.85;

                        // Tiny spin from collision
                        a.rotSpeed += (Math.random() - 0.5) * 0.05;
                        b.rotSpeed += (Math.random() - 0.5) * 0.05;
                    }
                }
            }

            // Cap speeds and dampen spin
            toyGroups.forEach(group => {
                group.driftSpeed = Math.min(group.driftSpeed, 0.06);
                group.rotSpeed *= 0.98;
                group.rotSpeed = Math.max(-0.3, Math.min(0.3, group.rotSpeed));
            });

            // Also update ripple uniforms for all toy meshes
            toys.forEach(toy => {
                // Ripple uniforms are updated in updateUniforms()
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            const dt = Math.min(clock.getDelta(), 0.1);
            const elapsed = clock.getElapsedTime() * CONFIG.waveSpeed;

            updateRipples(dt);
            updateUniforms();
            updateToys(dt, elapsed);

            floor.material.uniforms.uTime.value = elapsed;
            water.material.uniforms.uTime.value = elapsed;

            // Animate waterfall
            if (window.waterfallMesh) {
                window.waterfallMesh.material.uniforms.uTime.value = elapsed;
            }

            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>
