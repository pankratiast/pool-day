<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pool Day</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #0a4a6e; }
        canvas { display: block; cursor: none; }
        #cursor {
            position: fixed;
            width: 24px;
            height: 24px;
            border: 2px solid rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            z-index: 1000;
            box-shadow: 0 0 10px rgba(255,255,255,0.3);
        }
        #cursor.active {
            transform: translate(-50%, -50%) scale(1.5);
            background: rgba(255, 255, 255, 0.2);
        }
        /* POV Slider */
        #pov-control {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 12px;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 20px;
            border-radius: 25px;
            backdrop-filter: blur(10px);
            z-index: 100;
        }
        #pov-control label {
            color: rgba(255, 255, 255, 0.8);
            font-family: system-ui, sans-serif;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        #pov-slider {
            width: 120px;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }
        #pov-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        #pov-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        /* Audio Control */
        #audio-control {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 100;
        }
        #audio-btn {
            width: 44px;
            height: 44px;
            border: none;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s, transform 0.2s;
        }
        #audio-btn:hover {
            background: rgba(0, 0, 0, 0.5);
            transform: scale(1.1);
        }
        #audio-btn svg {
            width: 20px;
            height: 20px;
            fill: rgba(255, 255, 255, 0.8);
        }
        #audio-btn.muted svg.unmuted,
        #audio-btn:not(.muted) svg.muted {
            display: none;
        }
        #audio-btn.muted svg.muted,
        #audio-btn:not(.muted) svg.unmuted {
            display: block;
        }
        /* Weather Controls */
        #weather-control {
            position: fixed;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 8px;
            z-index: 100;
        }
        .weather-btn {
            width: 44px;
            height: 44px;
            border: none;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s, transform 0.2s;
        }
        .weather-btn:hover {
            background: rgba(0, 0, 0, 0.5);
            transform: scale(1.1);
        }
        .weather-btn.active {
            background: rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }
        .weather-btn svg {
            width: 22px;
            height: 22px;
            fill: rgba(255, 255, 255, 0.8);
        }
    </style>
</head>
<body>
    <div id="cursor"></div>
    <div id="pov-control">
        <label>View</label>
        <input type="range" id="pov-slider" min="0" max="100" value="15">
    </div>

    <div id="weather-control">
        <button id="sunny-btn" class="weather-btn active" title="Sunny">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zM2 13h2c.55 0 1-.45 1-1s-.45-1-1-1H2c-.55 0-1 .45-1 1s.45 1 1 1zm18 0h2c.55 0 1-.45 1-1s-.45-1-1-1h-2c-.55 0-1 .45-1 1s.45 1 1 1zM11 2v2c0 .55.45 1 1 1s1-.45 1-1V2c0-.55-.45-1-1-1s-1 .45-1 1zm0 18v2c0 .55.45 1 1 1s1-.45 1-1v-2c0-.55-.45-1-1-1s-1 .45-1 1zM5.99 4.58c-.39-.39-1.03-.39-1.41 0-.39.39-.39 1.03 0 1.41l1.06 1.06c.39.39 1.03.39 1.41 0s.39-1.03 0-1.41L5.99 4.58zm12.37 12.37c-.39-.39-1.03-.39-1.41 0-.39.39-.39 1.03 0 1.41l1.06 1.06c.39.39 1.03.39 1.41 0 .39-.39.39-1.03 0-1.41l-1.06-1.06zm1.06-10.96c.39-.39.39-1.03 0-1.41-.39-.39-1.03-.39-1.41 0l-1.06 1.06c-.39.39-.39 1.03 0 1.41s1.03.39 1.41 0l1.06-1.06zM7.05 18.36c.39-.39.39-1.03 0-1.41-.39-.39-1.03-.39-1.41 0l-1.06 1.06c-.39.39-.39 1.03 0 1.41s1.03.39 1.41 0l1.06-1.06z"/>
            </svg>
        </button>
        <button id="rain-btn" class="weather-btn" title="Rain">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M12 2c-5.33 4.55-8 8.48-8 11.8 0 4.98 3.8 8.2 8 8.2s8-3.22 8-8.2c0-3.32-2.67-7.25-8-11.8zm0 18c-3.35 0-6-2.57-6-6.2 0-2.34 1.95-5.44 6-9.14 4.05 3.7 6 6.79 6 9.14 0 3.63-2.65 6.2-6 6.2zm-4.17-6c.37 0 .67.26.74.62.41 2.22 2.28 2.98 3.64 2.87.43-.02.79.32.79.75 0 .4-.32.73-.72.75-2.13.13-4.62-1.09-5.19-4.12a.75.75 0 01.74-.87z"/>
            </svg>
        </button>
    </div>

    <div id="audio-control">
        <audio id="bg-audio" loop>
            <source src="GORE - あなたの愛への奴隷.mp3" type="audio/mpeg">
        </audio>
        <button id="audio-btn" class="muted" title="Toggle sound">
            <!-- Unmuted icon (speaker with waves) -->
            <svg class="unmuted" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
            </svg>
            <!-- Muted icon (speaker with X) -->
            <svg class="muted" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/>
            </svg>
        </button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // ============================================================
        // MOBILE DETECTION
        // ============================================================
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
            || (navigator.maxTouchPoints > 0 && window.innerWidth < 1024);

        // ============================================================
        // CONFIG - Deeper blue like reference image
        // ============================================================
        const CONFIG = {
            // Rich cyan-blue like the reference
            poolColor: new THREE.Color(0x0891B2),
            poolColorDeep: new THREE.Color(0x0369A1),
            poolColorDark: new THREE.Color(0x075985),
            floorColor: new THREE.Color(0x7DD3FC),
            groutColor: new THREE.Color(0x38BDF8),
            waterDepth: 4.5,
            waveSpeed: 0.6,
            waveScale: 0.08,
            causticIntensity: 0.8,  // Brighter caustics
            maxRipples: 20,
            rippleSpeed: 2.5,
            rippleDecay: 1.0,
            rippleStrength: 0.4
        };

        // ============================================================
        // RIPPLES
        // ============================================================
        const ripples = [];
        const MAX_RIPPLES = CONFIG.maxRipples;

        // Pre-allocate Vector2 arrays to avoid GC pressure
        const ripplePositionsCache = [];
        const rippleParamsCache = [];
        for (let i = 0; i < MAX_RIPPLES; i++) {
            ripplePositionsCache.push(new THREE.Vector2(0, 0));
            rippleParamsCache.push(new THREE.Vector2(-1, 0));
        }

        function addRipple(x, z, strength = CONFIG.rippleStrength) {
            ripples.push({ x, z, time: 0, strength });
            if (ripples.length > MAX_RIPPLES) ripples.shift();
        }

        function updateRipples(dt) {
            for (let i = ripples.length - 1; i >= 0; i--) {
                ripples[i].time += dt;
                ripples[i].strength *= (1 - CONFIG.rippleDecay * dt);
                if (ripples[i].strength < 0.005 || ripples[i].time > 5) {
                    ripples.splice(i, 1);
                }
            }
        }

        function getRippleData() {
            const positions = [], params = [];
            for (let i = 0; i < MAX_RIPPLES; i++) {
                if (i < ripples.length) {
                    positions.push(ripples[i].x, ripples[i].z);
                    params.push(ripples[i].time, ripples[i].strength);
                } else {
                    positions.push(0, 0);
                    params.push(-1, 0);
                }
            }
            return { positions, params };
        }

        // ============================================================
        // NOISE GLSL
        // ============================================================
        const NoiseGLSL = `
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

            float snoise(vec3 v) {
                const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i = floor(v + dot(v, C.yyy));
                vec3 x0 = v - i + dot(i, C.xxx);
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min(g.xyz, l.zxy);
                vec3 i2 = max(g.xyz, l.zxy);
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;
                i = mod289(i);
                vec4 p = permute(permute(permute(
                    i.z + vec4(0.0, i1.z, i2.z, 1.0))
                    + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                    + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                float n_ = 0.142857142857;
                vec3 ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_);
                vec4 x = x_ * ns.x + ns.yyyy;
                vec4 y = y_ * ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4(x.xy, y.xy);
                vec4 b1 = vec4(x.zw, y.zw);
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                vec3 p0 = vec3(a0.xy, h.x);
                vec3 p1 = vec3(a0.zw, h.y);
                vec3 p2 = vec3(a1.xy, h.z);
                vec3 p3 = vec3(a1.zw, h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
            }
        `;

        // ============================================================
        // RIPPLE GLSL
        // ============================================================
        const RippleGLSL = `
            #define MAX_RIPPLES 20
            uniform vec2 uRipplePositions[MAX_RIPPLES];
            uniform vec2 uRippleParams[MAX_RIPPLES];
            uniform float uRippleSpeed;

            float calcRipples(vec2 pos) {
                float total = 0.0;
                for (int i = 0; i < MAX_RIPPLES; i++) {
                    float t = uRippleParams[i].x;
                    float s = uRippleParams[i].y;
                    if (t < 0.0) continue;
                    float d = length(pos - uRipplePositions[i]);
                    float r = t * uRippleSpeed;
                    float w = 0.5 + t * 0.15;
                    total += sin((d - r) * 10.0) * exp(-((d-r)*(d-r)) / (w*w)) * s;
                }
                return total;
            }
        `;

        // ============================================================
        // FLOOR SHADER - Enhanced caustics
        // ============================================================
        const floorVS = `
            varying vec2 vUv;
            varying vec3 vWorldPos;
            void main() {
                vUv = uv;
                vec4 wp = modelMatrix * vec4(position, 1.0);
                vWorldPos = wp.xyz;
                gl_Position = projectionMatrix * viewMatrix * wp;
            }
        `;

        const floorFS = `
            uniform float uTime;
            uniform vec3 uPoolColor;
            uniform vec3 uPoolColorDeep;
            uniform vec3 uPoolColorDark;
            uniform vec3 uFloorColor;
            uniform vec3 uGroutColor;
            uniform float uWaterDepth;
            uniform float uCausticIntensity;

            varying vec2 vUv;
            varying vec3 vWorldPos;

            ${NoiseGLSL}
            ${RippleGLSL}

            float tiles(vec2 uv) {
                vec2 t = fract(uv * 1.2);
                float g = 0.02;
                return smoothstep(0.0, g, t.x) * smoothstep(0.0, g, 1.0-t.x) *
                       smoothstep(0.0, g, t.y) * smoothstep(0.0, g, 1.0-t.y);
            }

            float getHeight(vec2 p, float t) {
                float h = snoise(vec3(p * 0.3, t * 0.2)) * 0.6;
                h += snoise(vec3(p * 0.7, t * 0.35)) * 0.3;
                h += snoise(vec3(p * 1.5, t * 0.5)) * 0.15;
                h += calcRipples(p);
                return h * 0.08;
            }

            vec3 getNormal(vec2 p, float t) {
                float e = 0.06;
                float h = getHeight(p, t);
                float hx = getHeight(p + vec2(e, 0.0), t);
                float hz = getHeight(p + vec2(0.0, e), t);
                return normalize(vec3(h - hx, e * 0.5, h - hz));
            }

            // Enhanced caustics - brighter, more defined
            float caustics(vec2 p, float t) {
                float c = 0.0;

                // Multiple scales of caustics
                for (int s = 0; s < 2; s++) {
                    float scale = 1.0 + float(s) * 0.5;
                    vec2 sp = p * scale;

                    for (int i = -1; i <= 1; i++) {
                        for (int j = -1; j <= 1; j++) {
                            vec2 off = vec2(float(i), float(j)) * 0.15;
                            vec2 sampleP = sp + off;
                            vec3 n = getNormal(sampleP / scale, t);
                            vec3 refr = refract(vec3(0.0, -1.0, 0.0), n, 0.75);
                            float h = getHeight(sampleP / scale, t);
                            float dist = (uWaterDepth + h) / max(-refr.y, 0.01);
                            vec2 hit = sampleP + refr.xz * dist * scale;
                            c += exp(-length(hit - p * scale) * 3.5);
                        }
                    }
                }

                // Add bright caustic lines
                vec3 n1 = getNormal(p * 1.2, t * 0.9);
                vec3 n2 = getNormal(p * 0.8, t * 1.1);
                float lines = pow(1.0 - (abs(n1.x) + abs(n1.z)) * 0.7, 4.0);
                lines += pow(1.0 - (abs(n2.x) + abs(n2.z)) * 0.7, 5.0) * 0.5;

                return (c / 18.0) * 2.0 + lines * 0.6;
            }

            void main() {
                vec2 wp = vWorldPos.xz;

                // Subtle tile pattern
                float tile = tiles(wp);
                vec3 base = mix(uGroutColor, uFloorColor, tile * 0.3 + 0.7);

                // Caustics - bright and prominent
                float caust = caustics(wp, uTime);
                caust = pow(max(caust, 0.0), 1.2) * uCausticIntensity;

                // Bright caustic color (white-cyan)
                vec3 causticColor = vec3(0.9, 1.0, 1.0);
                vec3 col = base * 0.4 + caust * causticColor;

                // Deep blue water tint
                col = mix(col, uPoolColor, 0.5);
                col = mix(col, uPoolColorDeep, 0.3);

                // Depth fade at edges
                float edgeDist = min(min(vUv.x, 1.0 - vUv.x), min(vUv.y, 1.0 - vUv.y));
                col = mix(uPoolColorDark, col, smoothstep(0.0, 0.15, edgeDist));

                gl_FragColor = vec4(col, 1.0);
            }
        `;

        // ============================================================
        // WATER SURFACE SHADER
        // ============================================================
        const waterVS = `
            uniform float uTime;
            uniform float uWaveScale;

            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vWorldPos;
            varying float vHeight;

            ${NoiseGLSL}
            ${RippleGLSL}

            void main() {
                vUv = uv;
                vec3 pos = position;

                float wave = snoise(vec3(pos.xz * 0.3, uTime * 0.2)) * 0.6;
                wave += snoise(vec3(pos.xz * 0.7, uTime * 0.35)) * 0.3;
                wave += snoise(vec3(pos.xz * 1.5, uTime * 0.5)) * 0.15;
                wave += calcRipples(pos.xz);

                pos.y += wave * uWaveScale;
                vHeight = wave * uWaveScale;

                float e = 0.2;
                float wx = snoise(vec3((pos.x+e) * 0.3, pos.z * 0.3, uTime * 0.2)) * 0.6 +
                           snoise(vec3((pos.x+e) * 0.7, pos.z * 0.7, uTime * 0.35)) * 0.3 +
                           calcRipples(pos.xz + vec2(e, 0.0));
                float wz = snoise(vec3(pos.x * 0.3, (pos.z+e) * 0.3, uTime * 0.2)) * 0.6 +
                           snoise(vec3(pos.x * 0.7, (pos.z+e) * 0.7, uTime * 0.35)) * 0.3 +
                           calcRipples(pos.xz + vec2(0.0, e));

                vNormal = normalize(vec3((wave - wx) * uWaveScale * 2.0, e, (wave - wz) * uWaveScale * 2.0));

                vec4 wp = modelMatrix * vec4(pos, 1.0);
                vWorldPos = wp.xyz;
                gl_Position = projectionMatrix * viewMatrix * wp;
            }
        `;

        const waterFS = `
            uniform vec3 uPoolColor;
            uniform vec3 uPoolColorDeep;

            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vWorldPos;
            varying float vHeight;

            void main() {
                vec3 view = normalize(cameraPosition - vWorldPos);
                float fresnel = pow(1.0 - max(dot(view, vNormal), 0.0), 2.0);

                vec3 col = mix(uPoolColor, uPoolColorDeep, 0.3 + fresnel * 0.3);

                // Specular
                vec3 light = normalize(vec3(0.2, 1.0, 0.3));
                vec3 h = normalize(light + view);
                float spec = pow(max(dot(vNormal, h), 0.0), 64.0);
                col += spec * vec3(1.0, 0.98, 0.95) * 0.6;

                gl_FragColor = vec4(col, 0.08 + fresnel * 0.12);
            }
        `;

        // ============================================================
        // TOY SHADERS
        // ============================================================
        const toyVS = `
            uniform float uTime;
            uniform vec3 uToyPosition;
            uniform float uToyRotation;
            uniform float uBobPhase;
            uniform float uToyScale;
            uniform vec3 uPartOffset;

            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vWorldPos;
            varying vec3 vLocalPos;

            ${NoiseGLSL}
            ${RippleGLSL}

            void main() {
                vUv = uv;
                vLocalPos = position;

                float waterH = snoise(vec3(uToyPosition.xz * 0.3, uTime * 0.2)) * 0.6;
                waterH += snoise(vec3(uToyPosition.xz * 0.7, uTime * 0.35)) * 0.3;
                waterH += calcRipples(uToyPosition.xz);
                waterH *= 0.08;

                float bob = sin(uTime * 1.3 + uBobPhase) * 0.025;

                vec3 pos = position * uToyScale;

                // Add part offset (for compound toys)
                pos += uPartOffset;

                // Rotate around Y
                float c = cos(uToyRotation);
                float s = sin(uToyRotation);
                pos.xz = vec2(pos.x * c - pos.z * s, pos.x * s + pos.z * c);

                vec3 norm = normal;
                norm.xz = vec2(norm.x * c - norm.z * s, norm.x * s + norm.z * c);
                vNormal = normalize(norm);

                pos += uToyPosition + vec3(0.0, waterH + bob + 0.05, 0.0);

                vWorldPos = pos;
                gl_Position = projectionMatrix * viewMatrix * vec4(pos, 1.0);
            }
        `;

        const toyFS = `
            uniform vec3 uToyColor;
            uniform vec3 uToyColor2;
            uniform float uStripeCount;
            uniform vec3 uToyPosition;
            uniform int uToyType;

            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vWorldPos;
            varying vec3 vLocalPos;

            void main() {
                vec3 view = normalize(cameraPosition - vWorldPos);
                vec3 light = normalize(vec3(0.3, 1.0, 0.2));

                vec3 baseColor = uToyColor;

                // Stripes for rings
                if (uStripeCount > 0.5) {
                    float angle = atan(vLocalPos.z, vLocalPos.x);
                    float stripe = sin(angle * uStripeCount);
                    baseColor = mix(uToyColor, uToyColor2, step(0.0, stripe));
                }

                // Flamingo gradient (type 2)
                if (uToyType == 2) {
                    float grad = smoothstep(-0.5, 0.5, vLocalPos.z);
                    baseColor = mix(uToyColor, uToyColor2, grad);
                }

                // Palm tree base/fronds (type 4)
                if (uToyType == 4) {
                    float grad = smoothstep(-0.3, 0.3, vLocalPos.y);
                    baseColor = mix(uToyColor2, uToyColor, grad);
                }

                // Palm trunk (type 5)
                if (uToyType == 5) {
                    // Subtle wood grain effect
                    float grain = sin(vLocalPos.y * 20.0) * 0.1 + 0.9;
                    baseColor = mix(uToyColor, uToyColor2, grain);
                }

                // Flamingo neck/head (type 6)
                if (uToyType == 6) {
                    baseColor = uToyColor;
                }

                // Beak (type 7) - gradient from black tip to orange
                if (uToyType == 7) {
                    float t = smoothstep(-0.1, 0.1, vLocalPos.z);
                    baseColor = mix(uToyColor, uToyColor2, t);
                }

                float diff = max(dot(vNormal, light), 0.0) * 0.5 + 0.5;

                vec3 h = normalize(light + view);
                float spec = pow(max(dot(vNormal, h), 0.0), 32.0) * 0.5;

                // Plastic-like rim
                float rim = pow(1.0 - max(dot(view, vNormal), 0.0), 2.0) * 0.2;

                vec3 col = baseColor * diff + spec * vec3(1.0) + rim * baseColor;

                gl_FragColor = vec4(col, 1.0);
            }
        `;

        // ============================================================
        // SCENE
        // ============================================================
        let scene, camera, renderer, clock;
        let floor, water;
        let toys = [];
        let raycaster, mouse;
        let cursorEl;
        let lastMousePos = new THREE.Vector2();
        let isMouseDown = false;
        let lastRippleT = 0;

        // Camera panning
        let cameraTarget = new THREE.Vector3(0, 0, 0);
        let cameraPanX = 0;
        let cameraPanZ = 0;
        let isDragging = false;
        let dragStart = new THREE.Vector2();
        let currentPOV = 15;

        // Weather system
        let currentWeather = 'sunny';
        let rainParticles = null;
        let rainGeometry = null;
        let dirLight = null;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x075985);

            // Camera with adjustable POV
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
            updateCameraPOV(15);  // Default: 1-2 o'clock position

            // Disable anti-aliasing on mobile for performance
            renderer = new THREE.WebGLRenderer({ antialias: !isMobile });
            renderer.setSize(window.innerWidth, window.innerHeight);
            // Lower pixel ratio on mobile (1 vs 2) for major performance boost
            renderer.setPixelRatio(isMobile ? 1 : Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            clock = new THREE.Clock();
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            cursorEl = document.getElementById('cursor');

            createBackdrop();
            createPoolEdges();
            createFloor();
            createWater();
            createGazebo();
            createPottedPlants();
            createTallPalmTree();
            createStatues();
            createDivingBoard();
            createPoolChair();
            createLadder();
            createToys();
            createRain();

            // Set initial sunny weather
            setWeather('sunny');

            window.addEventListener('resize', onResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mouseup', onMouseUp);
            window.addEventListener('touchstart', onTouchStart, { passive: false });
            window.addEventListener('touchmove', onTouchMove, { passive: false });
            window.addEventListener('touchend', onTouchEnd);

            // Right-click drag for panning
            window.addEventListener('contextmenu', (e) => e.preventDefault());
            window.addEventListener('wheel', onWheel, { passive: false });

            // POV slider
            const povSlider = document.getElementById('pov-slider');
            povSlider.addEventListener('input', (e) => {
                updateCameraPOV(parseFloat(e.target.value));
            });

            // Audio control
            const audioBtn = document.getElementById('audio-btn');
            const bgAudio = document.getElementById('bg-audio');
            bgAudio.volume = 0.5;

            audioBtn.addEventListener('click', () => {
                if (audioBtn.classList.contains('muted')) {
                    bgAudio.play();
                    audioBtn.classList.remove('muted');
                } else {
                    bgAudio.pause();
                    audioBtn.classList.add('muted');
                }
            });

            // Weather controls
            document.getElementById('sunny-btn').addEventListener('click', () => setWeather('sunny'));
            document.getElementById('rain-btn').addEventListener('click', () => setWeather('rain'));
        }

        // Update camera position based on POV slider and pan offset
        function updateCameraPOV(value) {
            currentPOV = value;
            const t = value / 100;
            const height = 16 - t * 5;
            const zOffset = t * 10;
            camera.position.set(cameraPanX, height, zOffset + cameraPanZ);
            cameraTarget.set(cameraPanX, 0, cameraPanZ);
            camera.lookAt(cameraTarget);
        }

        // Handle mouse wheel for zooming/panning
        function onWheel(e) {
            e.preventDefault();
            // Shift+wheel for horizontal pan, regular wheel for forward/back
            if (e.shiftKey) {
                cameraPanX += e.deltaY * 0.01;
            } else {
                cameraPanZ += e.deltaY * 0.01;
            }
            // Clamp panning
            cameraPanX = Math.max(-8, Math.min(8, cameraPanX));
            cameraPanZ = Math.max(-8, Math.min(8, cameraPanZ));
            updateCameraPOV(currentPOV);
        }

        // ============================================================
        // BACKDROP - Rocky cliffs, waterfall, grass (Chao Island style)
        // ============================================================
        const rockVS = `
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vWorldPos;
            void main() {
                vUv = uv;
                vNormal = normalize(normalMatrix * normal);
                vec4 wp = modelMatrix * vec4(position, 1.0);
                vWorldPos = wp.xyz;
                gl_Position = projectionMatrix * viewMatrix * wp;
            }
        `;

        const rockFS = `
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vWorldPos;

            // Simple hash for noise
            float hash(vec2 p) {
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
            }

            float noise(vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                f = f * f * (3.0 - 2.0 * f);
                float a = hash(i);
                float b = hash(i + vec2(1.0, 0.0));
                float c = hash(i + vec2(0.0, 1.0));
                float d = hash(i + vec2(1.0, 1.0));
                return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
            }

            void main() {
                vec3 light = normalize(vec3(0.3, 1.0, 0.2));
                float diff = max(dot(vNormal, light), 0.0) * 0.5 + 0.5;

                // Rocky texture
                float n = noise(vWorldPos.xz * 2.0) * 0.5 + noise(vWorldPos.xy * 4.0) * 0.3;

                // Base rock colors (gray-purple like Chao Island)
                vec3 rockColor1 = vec3(0.45, 0.42, 0.5);
                vec3 rockColor2 = vec3(0.55, 0.52, 0.58);
                vec3 rockColor3 = vec3(0.38, 0.35, 0.42);

                vec3 col = mix(rockColor1, rockColor2, n);
                col = mix(col, rockColor3, noise(vWorldPos.yz * 3.0) * 0.4);

                col *= diff;

                // Darken crevices based on normal
                float crevice = 1.0 - abs(vNormal.y) * 0.3;
                col *= crevice;

                gl_FragColor = vec4(col, 1.0);
            }
        `;

        const waterfallVS = `
            varying vec2 vUv;
            varying vec3 vWorldPos;
            void main() {
                vUv = uv;
                vec4 wp = modelMatrix * vec4(position, 1.0);
                vWorldPos = wp.xyz;
                gl_Position = projectionMatrix * viewMatrix * wp;
            }
        `;

        const waterfallFS = `
            uniform float uTime;
            varying vec2 vUv;
            varying vec3 vWorldPos;

            float hash(vec2 p) {
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
            }

            float noise(vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                f = f * f * (3.0 - 2.0 * f);
                return mix(mix(hash(i), hash(i + vec2(1.0, 0.0)), f.x),
                           mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), f.x), f.y);
            }

            void main() {
                vec2 uv = vUv;

                // Flowing water effect
                float flow = uTime * 2.0;
                float n1 = noise(vec2(uv.x * 8.0, uv.y * 4.0 - flow));
                float n2 = noise(vec2(uv.x * 12.0 + 5.0, uv.y * 6.0 - flow * 1.3));
                float n3 = noise(vec2(uv.x * 20.0, uv.y * 10.0 - flow * 1.8));

                float foam = smoothstep(0.5, 0.8, n1) + smoothstep(0.6, 0.9, n2) * 0.5;
                foam += smoothstep(0.7, 1.0, n3) * 0.3;

                // Water colors
                vec3 waterColor = vec3(0.3, 0.6, 0.8);
                vec3 foamColor = vec3(0.85, 0.95, 1.0);

                vec3 col = mix(waterColor, foamColor, foam * 0.7);

                // Brighter at edges (splash)
                float edge = smoothstep(0.0, 0.15, uv.x) * smoothstep(0.0, 0.15, 1.0 - uv.x);
                col = mix(foamColor, col, edge);

                // Fade at bottom (mist)
                float mist = smoothstep(0.0, 0.3, uv.y);
                col = mix(vec3(0.7, 0.85, 0.95), col, mist);

                gl_FragColor = vec4(col, 0.9);
            }
        `;

        const grassFS = `
            varying vec2 vUv;
            varying vec3 vWorldPos;

            float hash(vec2 p) {
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
            }

            float noise(vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                f = f * f * (3.0 - 2.0 * f);
                return mix(mix(hash(i), hash(i + vec2(1.0, 0.0)), f.x),
                           mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), f.x), f.y);
            }

            void main() {
                float n = noise(vWorldPos.xz * 3.0);
                float n2 = noise(vWorldPos.xz * 8.0);

                vec3 grass1 = vec3(0.2, 0.6, 0.15);
                vec3 grass2 = vec3(0.3, 0.75, 0.2);
                vec3 grass3 = vec3(0.15, 0.5, 0.1);

                vec3 col = mix(grass1, grass2, n);
                col = mix(col, grass3, n2 * 0.3);

                // Slight variation
                col *= 0.9 + n2 * 0.2;

                gl_FragColor = vec4(col, 1.0);
            }
        `;

        // Sand shader
        const sandFS = `
            varying vec2 vUv;
            varying vec3 vWorldPos;

            float hash(vec2 p) {
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
            }

            float noise(vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                f = f * f * (3.0 - 2.0 * f);
                return mix(mix(hash(i), hash(i + vec2(1.0, 0.0)), f.x),
                           mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), f.x), f.y);
            }

            void main() {
                float n = noise(vWorldPos.xz * 5.0);
                float n2 = noise(vWorldPos.xz * 15.0);
                float n3 = noise(vWorldPos.xz * 30.0);

                // Sandy beach colors
                vec3 sand1 = vec3(0.96, 0.87, 0.70);
                vec3 sand2 = vec3(0.91, 0.82, 0.65);
                vec3 sand3 = vec3(0.85, 0.75, 0.58);

                vec3 col = mix(sand1, sand2, n);
                col = mix(col, sand3, n2 * 0.3);

                // Fine grain detail
                col *= 0.95 + n3 * 0.1;

                gl_FragColor = vec4(col, 1.0);
            }
        `;

        // Gravel shader
        const gravelFS = `
            varying vec2 vUv;
            varying vec3 vWorldPos;

            float hash(vec2 p) {
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
            }

            float noise(vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                f = f * f * (3.0 - 2.0 * f);
                return mix(mix(hash(i), hash(i + vec2(1.0, 0.0)), f.x),
                           mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), f.x), f.y);
            }

            void main() {
                float n = noise(vWorldPos.xz * 4.0);
                float n2 = noise(vWorldPos.xz * 12.0);
                float n3 = noise(vWorldPos.xz * 25.0);

                // Gravel colors (gray tones with some variation)
                vec3 gravel1 = vec3(0.55, 0.52, 0.50);
                vec3 gravel2 = vec3(0.65, 0.62, 0.58);
                vec3 gravel3 = vec3(0.45, 0.43, 0.40);

                vec3 col = mix(gravel1, gravel2, n);
                col = mix(col, gravel3, n2 * 0.4);

                // Rocky texture detail
                float rocks = step(0.6, n3);
                col = mix(col, col * 1.15, rocks * 0.3);
                col *= 0.9 + n3 * 0.2;

                gl_FragColor = vec4(col, 1.0);
            }
        `;

        function createBackdrop() {
            const rockMat = new THREE.ShaderMaterial({
                vertexShader: rockVS,
                fragmentShader: rockFS
            });

            // Main cliff wall (back) - larger and further back
            const cliffBack = new THREE.BoxGeometry(40, 15, 5);
            const cliffBackMesh = new THREE.Mesh(cliffBack, rockMat);
            cliffBackMesh.position.set(0, 3, -18);
            scene.add(cliffBackMesh);

            // Secondary back cliff layer (depth)
            const cliffBack2 = new THREE.BoxGeometry(35, 12, 4);
            const cliffBack2Mesh = new THREE.Mesh(cliffBack2, rockMat.clone());
            cliffBack2Mesh.position.set(0, 5, -20);
            scene.add(cliffBack2Mesh);

            // Sand area (left side) - beach-like
            const sandMat = new THREE.ShaderMaterial({
                vertexShader: rockVS,
                fragmentShader: sandFS
            });
            const sandArea = new THREE.PlaneGeometry(25, 50);
            sandArea.rotateX(-Math.PI / 2);
            const sandMesh = new THREE.Mesh(sandArea, sandMat);
            sandMesh.position.set(-22, -2.95, 0);
            scene.add(sandMesh);

            // Sand area (right side) - matching left side
            const sandMatRight = new THREE.ShaderMaterial({
                vertexShader: rockVS,
                fragmentShader: sandFS
            });
            const sandAreaRight = new THREE.PlaneGeometry(25, 50);
            sandAreaRight.rotateX(-Math.PI / 2);
            const sandMeshRight = new THREE.Mesh(sandAreaRight, sandMatRight);
            sandMeshRight.position.set(22, -2.95, 0);
            scene.add(sandMeshRight);

            // Stepped rocks (like in Chao Island) - behind the pool
            const stepRock1 = new THREE.BoxGeometry(6, 2.5, 3);
            const step1 = new THREE.Mesh(stepRock1, rockMat.clone());
            step1.position.set(-6, -1, -14);
            scene.add(step1);

            const stepRock2 = new THREE.BoxGeometry(5, 2, 2.5);
            const step2 = new THREE.Mesh(stepRock2, rockMat.clone());
            step2.position.set(5, -1.5, -13);
            scene.add(step2);

            const stepRock3 = new THREE.BoxGeometry(4, 3.5, 3);
            const step3 = new THREE.Mesh(stepRock3, rockMat.clone());
            step3.position.set(-10, 0, -12);
            scene.add(step3);

            const stepRock4 = new THREE.BoxGeometry(5, 2.5, 3);
            const step4 = new THREE.Mesh(stepRock4, rockMat.clone());
            step4.position.set(9, -0.5, -14);
            scene.add(step4);

            // Waterfall - positioned on the back cliff
            const waterfallMat = new THREE.ShaderMaterial({
                uniforms: { uTime: { value: 0 } },
                vertexShader: waterfallVS,
                fragmentShader: waterfallFS,
                transparent: true
            });

            const waterfallGeo = new THREE.PlaneGeometry(6, 12);
            const waterfall = new THREE.Mesh(waterfallGeo, waterfallMat);
            waterfall.position.set(-3, 4, -15.4);
            scene.add(waterfall);

            // Store waterfall for animation
            window.waterfallMesh = waterfall;

            // Splash pool at base of waterfall
            const splashGeo = new THREE.CircleGeometry(3, 16);
            splashGeo.rotateX(-Math.PI / 2);
            const splashMat = new THREE.MeshBasicMaterial({
                color: 0x6BBED9,
                transparent: true,
                opacity: 0.6
            });
            const splash = new THREE.Mesh(splashGeo, splashMat);
            splash.position.set(-3, -2.9, -13);
            scene.add(splash);

            // Grass areas - front and back of pool
            const grassMat = new THREE.ShaderMaterial({
                vertexShader: rockVS,
                fragmentShader: grassFS
            });

            // Front grass area
            const grassFront = new THREE.PlaneGeometry(50, 20);
            grassFront.rotateX(-Math.PI / 2);
            const grassFrontMesh = new THREE.Mesh(grassFront, grassMat.clone());
            grassFrontMesh.position.set(0, -2.95, 22);
            scene.add(grassFrontMesh);

            // Back grass (between pool and cliffs)
            const grassBack = new THREE.PlaneGeometry(50, 10);
            grassBack.rotateX(-Math.PI / 2);
            const grassBackMesh = new THREE.Mesh(grassBack, grassMat.clone());
            grassBackMesh.position.set(0, -2.95, -17);
            scene.add(grassBackMesh);
        }

        // ============================================================
        // POOL EDGES - Walls and coping
        // ============================================================
        function createPoolEdges() {
            const poolWidth = 16;
            const poolLength = 20;
            const wallHeight = 0.8;
            const wallThickness = 0.5;
            const copingWidth = 0.6;
            const copingHeight = 0.15;

            // Pool wall material (white marble)
            const wallMat = new THREE.MeshStandardMaterial({
                color: 0xFAFAFA,
                roughness: 0.3,
                metalness: 0.1
            });

            // Pool coping material (pink marble trim)
            const copingMat = new THREE.MeshStandardMaterial({
                color: 0xF5C6D0,
                roughness: 0.35,
                metalness: 0.05
            });

            // Add ambient and directional light for materials
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 5);
            scene.add(dirLight);

            // Back wall (far side - where diving board will be)
            const backWall = new THREE.BoxGeometry(poolWidth + wallThickness * 2, wallHeight, wallThickness);
            const backWallMesh = new THREE.Mesh(backWall, wallMat);
            backWallMesh.position.set(0, -CONFIG.waterDepth + wallHeight / 2, -poolLength / 2 - wallThickness / 2);
            scene.add(backWallMesh);

            // Front wall (near side)
            const frontWall = new THREE.BoxGeometry(poolWidth + wallThickness * 2, wallHeight, wallThickness);
            const frontWallMesh = new THREE.Mesh(frontWall, wallMat.clone());
            frontWallMesh.position.set(0, -CONFIG.waterDepth + wallHeight / 2, poolLength / 2 + wallThickness / 2);
            scene.add(frontWallMesh);

            // Left wall
            const leftWall = new THREE.BoxGeometry(wallThickness, wallHeight, poolLength);
            const leftWallMesh = new THREE.Mesh(leftWall, wallMat.clone());
            leftWallMesh.position.set(-poolWidth / 2 - wallThickness / 2, -CONFIG.waterDepth + wallHeight / 2, 0);
            scene.add(leftWallMesh);

            // Right wall (where ladder will be)
            const rightWall = new THREE.BoxGeometry(wallThickness, wallHeight, poolLength);
            const rightWallMesh = new THREE.Mesh(rightWall, wallMat.clone());
            rightWallMesh.position.set(poolWidth / 2 + wallThickness / 2, -CONFIG.waterDepth + wallHeight / 2, 0);
            scene.add(rightWallMesh);

            // Pool coping (lip around the edge)
            // Back coping
            const backCoping = new THREE.BoxGeometry(poolWidth + copingWidth * 2 + wallThickness * 2, copingHeight, copingWidth);
            const backCopingMesh = new THREE.Mesh(backCoping, copingMat);
            backCopingMesh.position.set(0, -CONFIG.waterDepth + wallHeight + copingHeight / 2, -poolLength / 2 - wallThickness - copingWidth / 2 + 0.1);
            scene.add(backCopingMesh);

            // Front coping
            const frontCoping = new THREE.BoxGeometry(poolWidth + copingWidth * 2 + wallThickness * 2, copingHeight, copingWidth);
            const frontCopingMesh = new THREE.Mesh(frontCoping, copingMat.clone());
            frontCopingMesh.position.set(0, -CONFIG.waterDepth + wallHeight + copingHeight / 2, poolLength / 2 + wallThickness + copingWidth / 2 - 0.1);
            scene.add(frontCopingMesh);

            // Left coping
            const leftCoping = new THREE.BoxGeometry(copingWidth, copingHeight, poolLength + copingWidth * 2);
            const leftCopingMesh = new THREE.Mesh(leftCoping, copingMat.clone());
            leftCopingMesh.position.set(-poolWidth / 2 - wallThickness - copingWidth / 2 + 0.1, -CONFIG.waterDepth + wallHeight + copingHeight / 2, 0);
            scene.add(leftCopingMesh);

            // Right coping
            const rightCoping = new THREE.BoxGeometry(copingWidth, copingHeight, poolLength + copingWidth * 2);
            const rightCopingMesh = new THREE.Mesh(rightCoping, copingMat.clone());
            rightCopingMesh.position.set(poolWidth / 2 + wallThickness + copingWidth / 2 - 0.1, -CONFIG.waterDepth + wallHeight + copingHeight / 2, 0);
            scene.add(rightCopingMesh);

            // Pool deck (surrounding area - white marble)
            const deckMat = new THREE.MeshStandardMaterial({
                color: 0xF0F0F0,
                roughness: 0.4,
                metalness: 0.08
            });

            // Back deck
            const backDeck = new THREE.BoxGeometry(poolWidth + 6, 0.2, 4);
            const backDeckMesh = new THREE.Mesh(backDeck, deckMat);
            backDeckMesh.position.set(0, -CONFIG.waterDepth + wallHeight + 0.05, -poolLength / 2 - 3);
            scene.add(backDeckMesh);

            // Front deck
            const frontDeck = new THREE.BoxGeometry(poolWidth + 6, 0.2, 4);
            const frontDeckMesh = new THREE.Mesh(frontDeck, deckMat.clone());
            frontDeckMesh.position.set(0, -CONFIG.waterDepth + wallHeight + 0.05, poolLength / 2 + 3);
            scene.add(frontDeckMesh);

            // Left deck
            const leftDeck = new THREE.BoxGeometry(3, 0.2, poolLength + 8);
            const leftDeckMesh = new THREE.Mesh(leftDeck, deckMat.clone());
            leftDeckMesh.position.set(-poolWidth / 2 - 2.5, -CONFIG.waterDepth + wallHeight + 0.05, 0);
            scene.add(leftDeckMesh);

            // Right deck
            const rightDeck = new THREE.BoxGeometry(3, 0.2, poolLength + 8);
            const rightDeckMesh = new THREE.Mesh(rightDeck, deckMat.clone());
            rightDeckMesh.position.set(poolWidth / 2 + 2.5, -CONFIG.waterDepth + wallHeight + 0.05, 0);
            scene.add(rightDeckMesh);
        }

        // ============================================================
        // DIVING BOARD
        // ============================================================
        function createGazebo() {
            // White marble material
            const marbleMat = new THREE.MeshStandardMaterial({
                color: 0xF5F5F5,
                roughness: 0.3,
                metalness: 0.1
            });

            const poolLength = 20;
            const deckY = -CONFIG.waterDepth + 0.8;
            const gazeboZ = -poolLength / 2 - 4;
            const gazeboY = deckY;

            // Circular base platform
            const baseGeo = new THREE.CylinderGeometry(3, 3.2, 0.3, 32);
            const baseMesh = new THREE.Mesh(baseGeo, marbleMat);
            baseMesh.position.set(0, gazeboY + 0.15, gazeboZ);
            scene.add(baseMesh);

            // Step
            const stepGeo = new THREE.CylinderGeometry(3.5, 3.7, 0.15, 32);
            const stepMesh = new THREE.Mesh(stepGeo, marbleMat.clone());
            stepMesh.position.set(0, gazeboY, gazeboZ);
            scene.add(stepMesh);

            // Columns (6 columns in a circle)
            const columnGeo = new THREE.CylinderGeometry(0.2, 0.25, 3.5, 16);
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const column = new THREE.Mesh(columnGeo.clone(), marbleMat.clone());
                column.position.set(
                    Math.cos(angle) * 2.5,
                    gazeboY + 2.05,
                    gazeboZ + Math.sin(angle) * 2.5
                );
                scene.add(column);

                // Column capital (decorative top)
                const capitalGeo = new THREE.BoxGeometry(0.5, 0.2, 0.5);
                const capital = new THREE.Mesh(capitalGeo, marbleMat.clone());
                capital.position.set(
                    Math.cos(angle) * 2.5,
                    gazeboY + 3.9,
                    gazeboZ + Math.sin(angle) * 2.5
                );
                scene.add(capital);

                // Column base
                const colBaseGeo = new THREE.CylinderGeometry(0.3, 0.35, 0.2, 16);
                const colBase = new THREE.Mesh(colBaseGeo, marbleMat.clone());
                colBase.position.set(
                    Math.cos(angle) * 2.5,
                    gazeboY + 0.4,
                    gazeboZ + Math.sin(angle) * 2.5
                );
                scene.add(colBase);
            }

            // Circular entablature (ring at top of columns)
            const ringGeo = new THREE.TorusGeometry(2.5, 0.25, 8, 32);
            ringGeo.rotateX(Math.PI / 2);
            const ringMesh = new THREE.Mesh(ringGeo, marbleMat.clone());
            ringMesh.position.set(0, gazeboY + 4.1, gazeboZ);
            scene.add(ringMesh);

            // Domed roof
            const domeGeo = new THREE.SphereGeometry(2.8, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const domeMesh = new THREE.Mesh(domeGeo, marbleMat.clone());
            domeMesh.position.set(0, gazeboY + 4.1, gazeboZ);
            scene.add(domeMesh);

            // Finial on top
            const finialGeo = new THREE.ConeGeometry(0.15, 0.5, 8);
            const finialMesh = new THREE.Mesh(finialGeo, marbleMat.clone());
            finialMesh.position.set(0, gazeboY + 7.1, gazeboZ);
            scene.add(finialMesh);

            // Decorative sphere under finial
            const sphereGeo = new THREE.SphereGeometry(0.2, 16, 12);
            const sphereMesh = new THREE.Mesh(sphereGeo, marbleMat.clone());
            sphereMesh.position.set(0, gazeboY + 6.7, gazeboZ);
            scene.add(sphereMesh);
        }

        // ============================================================
        // POTTED PLANTS (near gazebo)
        // ============================================================
        function createPottedPlants() {
            const poolLength = 20;
            const deckY = -CONFIG.waterDepth + 0.8;
            const gazeboZ = -poolLength / 2 - 4;

            // Terracotta pot material
            const potMat = new THREE.MeshStandardMaterial({
                color: 0xC67B4E,
                roughness: 0.7,
                metalness: 0.1
            });

            // Soil material
            const soilMat = new THREE.MeshStandardMaterial({
                color: 0x4A3728,
                roughness: 0.9,
                metalness: 0.0
            });

            // Plant leaf material
            const leafMat = new THREE.MeshStandardMaterial({
                color: 0x2D5A27,
                roughness: 0.6,
                metalness: 0.0
            });

            function createPottedPlant(x, z, plantType = 'bush') {
                const group = new THREE.Group();

                // Pot body
                const potGeo = new THREE.CylinderGeometry(0.35, 0.25, 0.5, 16);
                const pot = new THREE.Mesh(potGeo, potMat);
                pot.position.y = 0.25;
                group.add(pot);

                // Pot rim
                const rimGeo = new THREE.TorusGeometry(0.37, 0.05, 8, 16);
                rimGeo.rotateX(Math.PI / 2);
                const rim = new THREE.Mesh(rimGeo, potMat.clone());
                rim.position.y = 0.5;
                group.add(rim);

                // Soil
                const soilGeo = new THREE.CylinderGeometry(0.32, 0.32, 0.08, 16);
                const soil = new THREE.Mesh(soilGeo, soilMat);
                soil.position.y = 0.48;
                group.add(soil);

                if (plantType === 'bush') {
                    // Bushy plant with multiple leaf clusters
                    for (let i = 0; i < 5; i++) {
                        const leafCluster = new THREE.SphereGeometry(0.2 + Math.random() * 0.1, 8, 6);
                        const leaf = new THREE.Mesh(leafCluster, leafMat.clone());
                        const angle = (i / 5) * Math.PI * 2;
                        leaf.position.set(
                            Math.cos(angle) * 0.15,
                            0.7 + Math.random() * 0.2,
                            Math.sin(angle) * 0.15
                        );
                        group.add(leaf);
                    }
                    // Central top cluster
                    const topCluster = new THREE.SphereGeometry(0.25, 8, 6);
                    const top = new THREE.Mesh(topCluster, leafMat.clone());
                    top.position.y = 0.95;
                    group.add(top);
                } else if (plantType === 'fern') {
                    // Fern with upward spreading fronds
                    for (let i = 0; i < 8; i++) {
                        const frondGeo = new THREE.ConeGeometry(0.08, 0.6, 4);
                        const frond = new THREE.Mesh(frondGeo, leafMat.clone());
                        const angle = (i / 8) * Math.PI * 2;
                        frond.position.set(
                            Math.cos(angle) * 0.1,
                            0.7,
                            Math.sin(angle) * 0.1
                        );
                        frond.rotation.x = -0.4;
                        frond.rotation.y = angle;
                        group.add(frond);
                    }
                } else if (plantType === 'flowering') {
                    // Flowering plant with colorful blooms
                    const flowerMat = new THREE.MeshStandardMaterial({
                        color: 0xFF6B9D,
                        roughness: 0.5
                    });
                    // Leaves
                    for (let i = 0; i < 4; i++) {
                        const leafGeo = new THREE.SphereGeometry(0.15, 8, 6);
                        leafGeo.scale(1, 0.5, 1.5);
                        const leaf = new THREE.Mesh(leafGeo, leafMat.clone());
                        const angle = (i / 4) * Math.PI * 2;
                        leaf.position.set(
                            Math.cos(angle) * 0.2,
                            0.6,
                            Math.sin(angle) * 0.2
                        );
                        leaf.rotation.y = angle;
                        group.add(leaf);
                    }
                    // Flowers
                    for (let i = 0; i < 3; i++) {
                        const flowerGeo = new THREE.SphereGeometry(0.1, 8, 6);
                        const flower = new THREE.Mesh(flowerGeo, flowerMat);
                        flower.position.set(
                            (Math.random() - 0.5) * 0.3,
                            0.85 + Math.random() * 0.15,
                            (Math.random() - 0.5) * 0.3
                        );
                        group.add(flower);
                    }
                }

                group.position.set(x, deckY, z);
                scene.add(group);
            }

            // Place potted plants near the gazebo
            createPottedPlant(-2.5, gazeboZ + 2, 'bush');
            createPottedPlant(2.5, gazeboZ + 2, 'fern');
            createPottedPlant(-3.5, gazeboZ + 0.5, 'flowering');
            createPottedPlant(3.5, gazeboZ + 0.5, 'bush');
        }

        // ============================================================
        // TALL PALM TREE (top right area)
        // ============================================================
        function createTallPalmTree() {
            const poolWidth = 16;
            const poolLength = 20;
            const deckY = -CONFIG.waterDepth + 0.8;

            // Position: top right, above Hercules statue
            const palmX = poolWidth / 2 + 5;
            const palmZ = -poolLength / 2 + 2;

            // Trunk material (brown bark)
            const trunkMat = new THREE.MeshStandardMaterial({
                color: 0x8B5A2B,
                roughness: 0.9,
                metalness: 0.0
            });

            // Leaf material
            const leafMat = new THREE.MeshStandardMaterial({
                color: 0x228B22,
                roughness: 0.6,
                metalness: 0.0,
                side: THREE.DoubleSide
            });

            // Coconut material
            const coconutMat = new THREE.MeshStandardMaterial({
                color: 0x654321,
                roughness: 0.8,
                metalness: 0.0
            });

            const group = new THREE.Group();

            // Tall trunk with segments
            const trunkHeight = 5;
            const segments = 12;
            for (let i = 0; i < segments; i++) {
                const segmentHeight = trunkHeight / segments;
                const bottomRadius = 0.4 - (i * 0.02);
                const topRadius = 0.38 - (i * 0.02);
                const segmentGeo = new THREE.CylinderGeometry(topRadius, bottomRadius, segmentHeight, 12);
                const segment = new THREE.Mesh(segmentGeo, trunkMat.clone());
                segment.position.y = i * segmentHeight + segmentHeight / 2;

                // Add slight curve to trunk
                segment.position.x = Math.sin(i * 0.15) * 0.1;
                segment.position.z = Math.cos(i * 0.1) * 0.05;
                group.add(segment);

                // Segment rings (bark texture)
                if (i % 2 === 0) {
                    const ringGeo = new THREE.TorusGeometry(bottomRadius + 0.02, 0.03, 6, 16);
                    ringGeo.rotateX(Math.PI / 2);
                    const ring = new THREE.Mesh(ringGeo, trunkMat.clone());
                    ring.position.y = i * segmentHeight;
                    ring.position.x = segment.position.x;
                    ring.position.z = segment.position.z;
                    group.add(ring);
                }
            }

            // Crown of palm fronds
            const frondCount = 12;
            for (let i = 0; i < frondCount; i++) {
                const angle = (i / frondCount) * Math.PI * 2;

                // Each frond is made of multiple segments
                const frondGroup = new THREE.Group();

                // Main frond stem
                const stemLength = 3 + Math.random() * 0.5;
                const stemGeo = new THREE.CylinderGeometry(0.03, 0.05, stemLength, 6);
                const stem = new THREE.Mesh(stemGeo, leafMat.clone());
                stem.position.y = stemLength / 2;
                stem.rotation.x = 0.6 + Math.random() * 0.3;
                frondGroup.add(stem);

                // Leaflets along the stem
                for (let j = 0; j < 8; j++) {
                    const leafletGeo = new THREE.PlaneGeometry(0.15, 0.8);
                    const leaflet = new THREE.Mesh(leafletGeo, leafMat.clone());
                    leaflet.position.y = 0.4 + j * 0.3;
                    leaflet.position.x = 0.15;
                    leaflet.rotation.z = -0.3;
                    leaflet.rotation.y = 0.2;
                    frondGroup.add(leaflet);

                    const leaflet2 = new THREE.Mesh(leafletGeo.clone(), leafMat.clone());
                    leaflet2.position.y = 0.4 + j * 0.3;
                    leaflet2.position.x = -0.15;
                    leaflet2.rotation.z = 0.3;
                    leaflet2.rotation.y = -0.2;
                    frondGroup.add(leaflet2);
                }

                frondGroup.position.y = trunkHeight;
                frondGroup.rotation.y = angle;
                group.add(frondGroup);
            }

            // Coconuts (cluster at top of trunk)
            const coconutPositions = [
                [0.25, trunkHeight - 0.3, 0.1],
                [-0.2, trunkHeight - 0.4, 0.2],
                [0.1, trunkHeight - 0.2, -0.25],
                [-0.15, trunkHeight - 0.5, -0.15]
            ];
            coconutPositions.forEach(pos => {
                const coconutGeo = new THREE.SphereGeometry(0.2, 12, 10);
                coconutGeo.scale(1, 1.2, 1);
                const coconut = new THREE.Mesh(coconutGeo, coconutMat);
                coconut.position.set(pos[0], pos[1], pos[2]);
                group.add(coconut);
            });

            group.position.set(palmX, deckY - 0.5, palmZ);
            scene.add(group);

            // Create symmetrical palm tree on top left
            const group2 = group.clone();
            group2.position.set(-palmX, deckY - 0.5, palmZ);
            scene.add(group2);
        }

        // ============================================================
        // GREEK MARBLE STATUES
        // ============================================================
        function createStatues() {
            const marbleMat = new THREE.MeshStandardMaterial({
                color: 0xFAFAFA,
                roughness: 0.35,
                metalness: 0.05
            });

            const poolWidth = 16;
            const poolLength = 20;
            const deckY = -CONFIG.waterDepth + 0.8;

            // Create a simplified classical statue
            function createStatue(x, z, rotation = 0) {
                const group = new THREE.Group();

                // Pedestal
                const pedestalGeo = new THREE.BoxGeometry(0.8, 1.2, 0.8);
                const pedestal = new THREE.Mesh(pedestalGeo, marbleMat.clone());
                pedestal.position.y = 0.6;
                group.add(pedestal);

                // Pedestal top trim
                const trimGeo = new THREE.BoxGeometry(0.9, 0.1, 0.9);
                const trim = new THREE.Mesh(trimGeo, marbleMat.clone());
                trim.position.y = 1.25;
                group.add(trim);

                // Body/torso (elongated cylinder)
                const torsoGeo = new THREE.CylinderGeometry(0.25, 0.3, 1.2, 12);
                const torso = new THREE.Mesh(torsoGeo, marbleMat.clone());
                torso.position.y = 2.0;
                group.add(torso);

                // Chest/shoulders
                const chestGeo = new THREE.SphereGeometry(0.35, 12, 8);
                chestGeo.scale(1.2, 0.8, 0.8);
                const chest = new THREE.Mesh(chestGeo, marbleMat.clone());
                chest.position.y = 2.5;
                group.add(chest);

                // Head
                const headGeo = new THREE.SphereGeometry(0.22, 12, 10);
                headGeo.scale(0.85, 1, 0.9);
                const head = new THREE.Mesh(headGeo, marbleMat.clone());
                head.position.y = 3.0;
                group.add(head);

                // Draped cloth/robe effect (cone)
                const robeGeo = new THREE.ConeGeometry(0.45, 1.4, 12);
                const robe = new THREE.Mesh(robeGeo, marbleMat.clone());
                robe.position.y = 1.5;
                robe.rotation.x = Math.PI;
                group.add(robe);

                group.position.set(x, deckY, z);
                group.rotation.y = rotation;
                scene.add(group);
            }

            // Create Hercules statue (muscular, holding club)
            function createHercules(x, z, rotation = 0) {
                const group = new THREE.Group();

                // Larger pedestal for Hercules
                const pedestalGeo = new THREE.BoxGeometry(1.0, 1.4, 1.0);
                const pedestal = new THREE.Mesh(pedestalGeo, marbleMat.clone());
                pedestal.position.y = 0.7;
                group.add(pedestal);

                // Pedestal top trim
                const trimGeo = new THREE.BoxGeometry(1.1, 0.12, 1.1);
                const trim = new THREE.Mesh(trimGeo, marbleMat.clone());
                trim.position.y = 1.45;
                group.add(trim);

                // Muscular legs
                const legGeo = new THREE.CylinderGeometry(0.18, 0.15, 1.0, 10);
                const leftLeg = new THREE.Mesh(legGeo, marbleMat.clone());
                leftLeg.position.set(-0.15, 2.0, 0);
                group.add(leftLeg);
                const rightLeg = new THREE.Mesh(legGeo.clone(), marbleMat.clone());
                rightLeg.position.set(0.15, 2.0, 0);
                group.add(rightLeg);

                // Muscular torso (broader)
                const torsoGeo = new THREE.CylinderGeometry(0.35, 0.32, 1.0, 12);
                const torso = new THREE.Mesh(torsoGeo, marbleMat.clone());
                torso.position.y = 2.9;
                group.add(torso);

                // Broad chest/shoulders
                const chestGeo = new THREE.SphereGeometry(0.45, 12, 8);
                chestGeo.scale(1.4, 0.9, 0.9);
                const chest = new THREE.Mesh(chestGeo, marbleMat.clone());
                chest.position.y = 3.35;
                group.add(chest);

                // Muscular arms
                const armGeo = new THREE.CylinderGeometry(0.12, 0.1, 0.8, 8);
                const leftArm = new THREE.Mesh(armGeo, marbleMat.clone());
                leftArm.position.set(-0.5, 3.2, 0);
                leftArm.rotation.z = 0.3;
                group.add(leftArm);
                const rightArm = new THREE.Mesh(armGeo.clone(), marbleMat.clone());
                rightArm.position.set(0.5, 3.0, 0.1);
                rightArm.rotation.z = -0.8;
                group.add(rightArm);

                // Head
                const headGeo = new THREE.SphereGeometry(0.25, 12, 10);
                const head = new THREE.Mesh(headGeo, marbleMat.clone());
                head.position.y = 3.85;
                group.add(head);

                // Beard
                const beardGeo = new THREE.SphereGeometry(0.15, 8, 6);
                beardGeo.scale(1, 1.2, 0.8);
                const beard = new THREE.Mesh(beardGeo, marbleMat.clone());
                beard.position.set(0, 3.7, 0.15);
                group.add(beard);

                // Club (held in right hand, resting on ground)
                const clubGeo = new THREE.CylinderGeometry(0.08, 0.15, 2.0, 8);
                const club = new THREE.Mesh(clubGeo, marbleMat.clone());
                club.position.set(0.7, 2.2, 0.2);
                club.rotation.z = 0.15;
                group.add(club);

                // Lion skin draped (simplified as cloth on shoulder)
                const skinGeo = new THREE.SphereGeometry(0.25, 8, 6);
                skinGeo.scale(1.5, 0.6, 1);
                const skin = new THREE.Mesh(skinGeo, marbleMat.clone());
                skin.position.set(-0.4, 3.5, 0.2);
                group.add(skin);

                group.position.set(x, deckY, z);
                group.rotation.y = rotation;
                scene.add(group);
            }

            // Create nymph fountain statue (holding vessel that pours water)
            function createNymphFountain(x, z, rotation = 0) {
                const group = new THREE.Group();

                // Pedestal
                const pedestalGeo = new THREE.CylinderGeometry(0.5, 0.6, 1.0, 16);
                const pedestal = new THREE.Mesh(pedestalGeo, marbleMat.clone());
                pedestal.position.y = 0.5;
                group.add(pedestal);

                // Pedestal trim
                const trimGeo = new THREE.CylinderGeometry(0.55, 0.55, 0.1, 16);
                const trim = new THREE.Mesh(trimGeo, marbleMat.clone());
                trim.position.y = 1.05;
                group.add(trim);

                // Graceful body (slimmer, feminine)
                const bodyGeo = new THREE.CylinderGeometry(0.2, 0.25, 1.4, 12);
                const body = new THREE.Mesh(bodyGeo, marbleMat.clone());
                body.position.y = 1.85;
                group.add(body);

                // Shoulders/chest
                const chestGeo = new THREE.SphereGeometry(0.28, 12, 8);
                chestGeo.scale(1.1, 0.7, 0.8);
                const chest = new THREE.Mesh(chestGeo, marbleMat.clone());
                chest.position.y = 2.5;
                group.add(chest);

                // Head
                const headGeo = new THREE.SphereGeometry(0.18, 12, 10);
                const head = new THREE.Mesh(headGeo, marbleMat.clone());
                head.position.y = 2.9;
                group.add(head);

                // Hair (bun style)
                const hairGeo = new THREE.SphereGeometry(0.15, 8, 6);
                const hair = new THREE.Mesh(hairGeo, marbleMat.clone());
                hair.position.set(0, 3.05, -0.05);
                group.add(hair);

                // Flowing robe
                const robeGeo = new THREE.ConeGeometry(0.4, 1.5, 12);
                const robe = new THREE.Mesh(robeGeo, marbleMat.clone());
                robe.position.y = 1.35;
                robe.rotation.x = Math.PI;
                group.add(robe);

                // Arms holding vessel (raised, pouring into pool)
                const armGeo = new THREE.CylinderGeometry(0.06, 0.05, 0.6, 8);
                const arm = new THREE.Mesh(armGeo, marbleMat.clone());
                arm.position.set(0.3, 2.6, 0.2);
                arm.rotation.z = -0.5;
                arm.rotation.x = 0.3;
                group.add(arm);

                // Water vessel/amphora
                const vesselGeo = new THREE.CylinderGeometry(0.12, 0.08, 0.35, 12);
                const vessel = new THREE.Mesh(vesselGeo, marbleMat.clone());
                vessel.position.set(0.45, 2.7, 0.35);
                vessel.rotation.z = -0.8;
                vessel.rotation.x = 0.5;
                group.add(vessel);

                // Water stream (using thin cylinder, animated blue)
                const waterMat = new THREE.MeshStandardMaterial({
                    color: 0x4FC3F7,
                    transparent: true,
                    opacity: 0.7,
                    roughness: 0.1
                });
                const waterGeo = new THREE.CylinderGeometry(0.03, 0.05, 1.8, 8);
                const water = new THREE.Mesh(waterGeo, waterMat);
                water.position.set(0.55, 1.7, 0.5);
                water.rotation.z = -0.3;
                water.rotation.x = 0.4;
                group.add(water);

                // Water splash at bottom
                const splashGeo = new THREE.SphereGeometry(0.15, 8, 6);
                splashGeo.scale(1.5, 0.5, 1.5);
                const splash = new THREE.Mesh(splashGeo, waterMat.clone());
                splash.position.set(0.7, 0.9, 0.7);
                group.add(splash);

                group.position.set(x, deckY, z);
                group.rotation.y = rotation;
                scene.add(group);
            }

            // Place statues on the sides of the pool
            // Left side statues
            createStatue(-poolWidth / 2 - 3, -4, Math.PI / 6);
            createStatue(-poolWidth / 2 - 3, 4, -Math.PI / 6);

            // Right side - Hercules statue (replacing one regular statue)
            createHercules(poolWidth / 2 + 3, 0, -Math.PI / 4);

            // Back corners (near gazebo)
            createStatue(-poolWidth / 2 - 2, -poolLength / 2 - 1, Math.PI / 4);
            createStatue(poolWidth / 2 + 2, -poolLength / 2 - 1, -Math.PI / 4);

            // Nymph fountain statues at front corners of pool (top left and top right from camera view)
            createNymphFountain(-poolWidth / 2 + 1, poolLength / 2 - 1, Math.PI * 0.75);
            createNymphFountain(poolWidth / 2 - 1, poolLength / 2 - 1, -Math.PI * 0.75);
        }

        // ============================================================
        // WHITE DIVING BOARD (left side)
        // ============================================================
        function createDivingBoard() {
            const whiteMat = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                roughness: 0.4,
                metalness: 0.1
            });

            const poolWidth = 16;
            const deckY = -CONFIG.waterDepth + 0.8;
            const boardX = -poolWidth / 2 - 1.5;
            const boardZ = 0;

            // Base/stand
            const standGeo = new THREE.BoxGeometry(1.2, 0.8, 1.5);
            const stand = new THREE.Mesh(standGeo, whiteMat);
            stand.position.set(boardX - 0.8, deckY + 0.4, boardZ);
            scene.add(stand);

            // Support pillars
            const pillarGeo = new THREE.BoxGeometry(0.15, 1.2, 0.15);
            const leftPillar = new THREE.Mesh(pillarGeo, whiteMat.clone());
            leftPillar.position.set(boardX - 0.3, deckY + 1.4, boardZ - 0.5);
            scene.add(leftPillar);

            const rightPillar = new THREE.Mesh(pillarGeo.clone(), whiteMat.clone());
            rightPillar.position.set(boardX - 0.3, deckY + 1.4, boardZ + 0.5);
            scene.add(rightPillar);

            // The diving board plank
            const boardGeo = new THREE.BoxGeometry(3.5, 0.12, 0.7);
            const board = new THREE.Mesh(boardGeo, whiteMat.clone());
            board.position.set(boardX + 1.2, deckY + 2.0, boardZ);
            scene.add(board);

            // Non-slip surface texture (subtle ridges)
            const ridgeMat = new THREE.MeshStandardMaterial({
                color: 0xEEEEEE,
                roughness: 0.8,
                metalness: 0.0
            });
            const ridgeGeo = new THREE.BoxGeometry(3.2, 0.02, 0.6);
            const ridge = new THREE.Mesh(ridgeGeo, ridgeMat);
            ridge.position.set(boardX + 1.2, deckY + 2.07, boardZ);
            scene.add(ridge);

            // Side rails
            const railMat = new THREE.MeshStandardMaterial({
                color: 0xC0C0C0,
                roughness: 0.2,
                metalness: 0.9
            });
            const railGeo = new THREE.CylinderGeometry(0.03, 0.03, 1.0, 8);

            const leftRail = new THREE.Mesh(railGeo, railMat);
            leftRail.position.set(boardX - 0.2, deckY + 2.5, boardZ - 0.4);
            scene.add(leftRail);

            const rightRail = new THREE.Mesh(railGeo.clone(), railMat.clone());
            rightRail.position.set(boardX - 0.2, deckY + 2.5, boardZ + 0.4);
            scene.add(rightRail);

            // Horizontal rail connector
            const connectorGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.8, 8);
            connectorGeo.rotateX(Math.PI / 2);
            const connector = new THREE.Mesh(connectorGeo, railMat.clone());
            connector.position.set(boardX - 0.2, deckY + 3.0, boardZ);
            scene.add(connector);
        }

        // ============================================================
        // WHITE POOL CHAIR (left side, bottom corner)
        // ============================================================
        function createPoolChair() {
            const whiteMat = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                roughness: 0.5,
                metalness: 0.1
            });

            const poolWidth = 16;
            const poolLength = 20;
            const deckY = -CONFIG.waterDepth + 0.8;
            const chairX = -poolWidth / 2 - 2.5;
            const chairZ = poolLength / 2 - 2;

            // Chair legs
            const legGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.5, 8);
            const legPositions = [
                [-0.5, 0, -0.9],
                [0.5, 0, -0.9],
                [-0.5, 0, 0.9],
                [0.5, 0, 0.9]
            ];
            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(legGeo, whiteMat.clone());
                leg.position.set(chairX + pos[0], deckY + 0.25, chairZ + pos[2]);
                scene.add(leg);
            });

            // Seat base (horizontal slats)
            const slatGeo = new THREE.BoxGeometry(1.2, 0.06, 0.12);
            for (let i = 0; i < 8; i++) {
                const slat = new THREE.Mesh(slatGeo, whiteMat.clone());
                slat.position.set(chairX, deckY + 0.5, chairZ - 0.7 + i * 0.2);
                scene.add(slat);
            }

            // Backrest (angled at 45 degrees)
            const backGeo = new THREE.BoxGeometry(1.2, 0.06, 0.12);
            for (let i = 0; i < 6; i++) {
                const back = new THREE.Mesh(backGeo, whiteMat.clone());
                // Position along the 45-degree angle
                const zOffset = -0.9 - i * 0.12 * Math.cos(Math.PI / 4);
                const yOffset = 0.5 + i * 0.12 * Math.sin(Math.PI / 4);
                back.position.set(chairX, deckY + yOffset, chairZ + zOffset);
                back.rotation.x = -Math.PI / 4;
                scene.add(back);
            }

            // Side frame rails
            const frameGeo = new THREE.BoxGeometry(0.08, 0.08, 2.2);
            const leftFrame = new THREE.Mesh(frameGeo, whiteMat.clone());
            leftFrame.position.set(chairX - 0.55, deckY + 0.5, chairZ);
            scene.add(leftFrame);

            const rightFrame = new THREE.Mesh(frameGeo.clone(), whiteMat.clone());
            rightFrame.position.set(chairX + 0.55, deckY + 0.5, chairZ);
            scene.add(rightFrame);
        }

        // ============================================================
        // POOL LADDER
        // ============================================================
        function createLadder() {
            const metalMat = new THREE.MeshStandardMaterial({
                color: 0xC0C0C0,
                roughness: 0.2,
                metalness: 0.9
            });

            const poolWidth = 16;
            const deckY = -CONFIG.waterDepth + 0.8;
            const ladderX = poolWidth / 2 + 0.3;
            const ladderZ = 2;

            // Vertical rails
            const railGeo = new THREE.CylinderGeometry(0.04, 0.04, 2.5, 12);

            const leftRail = new THREE.Mesh(railGeo, metalMat);
            leftRail.position.set(ladderX, deckY - 0.4, ladderZ - 0.25);
            scene.add(leftRail);

            const rightRail = new THREE.Mesh(railGeo.clone(), metalMat.clone());
            rightRail.position.set(ladderX, deckY - 0.4, ladderZ + 0.25);
            scene.add(rightRail);

            // Curved top handles
            const handleCurve = new THREE.QuadraticBezierCurve3(
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(-0.3, 0.2, 0),
                new THREE.Vector3(-0.3, 0.5, 0)
            );
            const handleGeo = new THREE.TubeGeometry(handleCurve, 12, 0.04, 8, false);

            const leftHandle = new THREE.Mesh(handleGeo, metalMat.clone());
            leftHandle.position.set(ladderX, deckY + 0.8, ladderZ - 0.25);
            scene.add(leftHandle);

            const rightHandle = new THREE.Mesh(handleGeo.clone(), metalMat.clone());
            rightHandle.position.set(ladderX, deckY + 0.8, ladderZ + 0.25);
            scene.add(rightHandle);

            // Rungs (steps)
            const rungGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.5, 12);
            rungGeo.rotateX(Math.PI / 2);

            for (let i = 0; i < 4; i++) {
                const rung = new THREE.Mesh(rungGeo.clone(), metalMat.clone());
                rung.position.set(ladderX, deckY - 1.4 + i * 0.5, ladderZ);
                scene.add(rung);
            }
        }

        // ============================================================
        // RAIN SYSTEM
        // ============================================================
        function createRain() {
            // Fewer rain particles on mobile
            const rainCount = isMobile ? 1000 : 3000;
            rainGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(rainCount * 3);
            const velocities = new Float32Array(rainCount);

            for (let i = 0; i < rainCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 60;
                positions[i * 3 + 1] = Math.random() * 25;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 60;
                velocities[i] = 0.3 + Math.random() * 0.2;
            }

            rainGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            rainGeometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 1));

            const rainMaterial = new THREE.PointsMaterial({
                color: 0xaaccff,
                size: 0.08,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });

            rainParticles = new THREE.Points(rainGeometry, rainMaterial);
            rainParticles.visible = false;
            scene.add(rainParticles);
        }

        function updateRain() {
            if (!rainParticles || !rainParticles.visible) return;

            const positions = rainGeometry.attributes.position.array;
            const velocities = rainGeometry.attributes.velocity.array;

            for (let i = 0; i < positions.length / 3; i++) {
                positions[i * 3 + 1] -= velocities[i];

                // Reset raindrop when it falls below ground
                if (positions[i * 3 + 1] < -5) {
                    positions[i * 3 + 1] = 20 + Math.random() * 5;
                    positions[i * 3] = (Math.random() - 0.5) * 60;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 60;
                }
            }

            rainGeometry.attributes.position.needsUpdate = true;
        }

        function setWeather(weather) {
            currentWeather = weather;

            const sunnyBtn = document.getElementById('sunny-btn');
            const rainBtn = document.getElementById('rain-btn');

            if (weather === 'sunny') {
                sunnyBtn.classList.add('active');
                rainBtn.classList.remove('active');

                // Sunny settings
                scene.background = new THREE.Color(0x87CEEB);
                if (dirLight) dirLight.intensity = 0.8;
                if (rainParticles) rainParticles.visible = false;
            } else {
                sunnyBtn.classList.remove('active');
                rainBtn.classList.add('active');

                // Rainy settings - darker, moodier
                scene.background = new THREE.Color(0x4A5568);
                if (dirLight) dirLight.intensity = 0.3;
                if (rainParticles) rainParticles.visible = true;
            }
        }

        function createRippleUniforms() {
            return {
                uRipplePositions: { value: [] },
                uRippleParams: { value: [] },
                uRippleSpeed: { value: CONFIG.rippleSpeed }
            };
        }

        function createFloor() {
            const geo = new THREE.PlaneGeometry(16, 20);
            geo.rotateX(-Math.PI / 2);

            const mat = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uPoolColor: { value: CONFIG.poolColor },
                    uPoolColorDeep: { value: CONFIG.poolColorDeep },
                    uPoolColorDark: { value: CONFIG.poolColorDark },
                    uFloorColor: { value: CONFIG.floorColor },
                    uGroutColor: { value: CONFIG.groutColor },
                    uWaterDepth: { value: CONFIG.waterDepth },
                    uCausticIntensity: { value: CONFIG.causticIntensity },
                    ...createRippleUniforms()
                },
                vertexShader: floorVS,
                fragmentShader: floorFS
            });

            floor = new THREE.Mesh(geo, mat);
            floor.position.y = -CONFIG.waterDepth;
            scene.add(floor);
        }

        function createWater() {
            // Lower resolution on mobile: 32x40 vs 64x80 (4x fewer vertices)
            const segments = isMobile ? [32, 40] : [64, 80];
            const geo = new THREE.PlaneGeometry(16, 20, segments[0], segments[1]);
            geo.rotateX(-Math.PI / 2);

            const mat = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uWaveScale: { value: CONFIG.waveScale },
                    uPoolColor: { value: CONFIG.poolColor },
                    uPoolColorDeep: { value: CONFIG.poolColorDeep },
                    ...createRippleUniforms()
                },
                vertexShader: waterVS,
                fragmentShader: waterFS,
                transparent: true,
                depthWrite: false
            });

            water = new THREE.Mesh(geo, mat);
            scene.add(water);
        }

        // Track toy groups (compound toys that move together)
        let toyGroups = [];

        function createToys() {
            // Pink ring float - FLAT on water
            const pinkRing = new THREE.TorusGeometry(0.9, 0.3, 16, 32);
            pinkRing.rotateX(Math.PI / 2);
            createToyGroup({
                parts: [{ geometry: pinkRing, offset: [0, 0, 0], color1: 0xFF69B4, color2: 0xFFFFFF, stripes: 8, type: 0 }],
                position: new THREE.Vector3(-3, 0, -1.5),
                radius: 1.2,
                bobPhase: 0
            });

            // Yellow/Orange ring float
            const yellowRing = new THREE.TorusGeometry(0.85, 0.28, 16, 32);
            yellowRing.rotateX(Math.PI / 2);
            createToyGroup({
                parts: [{ geometry: yellowRing, offset: [0, 0, 0], color1: 0xFFD700, color2: 0xFFA500, stripes: 6, type: 0 }],
                position: new THREE.Vector3(3, 0, 1.5),
                radius: 1.1,
                bobPhase: 1.2
            });

            // Teal ring float
            const tealRing = new THREE.TorusGeometry(0.8, 0.26, 16, 32);
            tealRing.rotateX(Math.PI / 2);
            createToyGroup({
                parts: [{ geometry: tealRing, offset: [0, 0, 0], color1: 0x40E0D0, color2: 0xFFFFFF, stripes: 8, type: 0 }],
                position: new THREE.Vector3(0.5, 0, -3),
                radius: 1.0,
                bobPhase: 2.5
            });

            // FLAMINGO - standalone floating flamingo (no ring)
            // Flamingo body - wider and flatter to float on water
            const flamingoBody = new THREE.SphereGeometry(0.5, 16, 12);
            flamingoBody.scale(1.4, 0.5, 1.8);

            // Flamingo neck (curved cylinder - use a bent tube)
            const neckCurve = new THREE.QuadraticBezierCurve3(
                new THREE.Vector3(0, 0, 0.4),
                new THREE.Vector3(0, 0.7, 0.6),
                new THREE.Vector3(0, 1.1, 0.4)
            );
            const flamingoNeck = new THREE.TubeGeometry(neckCurve, 12, 0.1, 8, false);

            // Flamingo head
            const flamingoHead = new THREE.SphereGeometry(0.14, 12, 8);

            // Flamingo beak
            const flamingoBeak = new THREE.ConeGeometry(0.05, 0.18, 8);
            flamingoBeak.rotateX(Math.PI / 2);

            // Flamingo tail feathers
            const flamingoTail = new THREE.ConeGeometry(0.18, 0.5, 8);
            flamingoTail.rotateX(-0.5);

            // Flamingo wings (decorative bumps on sides)
            const flamingoWing = new THREE.SphereGeometry(0.25, 12, 8);
            flamingoWing.scale(0.6, 0.4, 1.2);

            createToyGroup({
                parts: [
                    { geometry: flamingoBody, offset: [0, 0, 0], color1: 0xFF1493, color2: 0xFF69B4, stripes: 0, type: 2 },
                    { geometry: flamingoWing, offset: [0.35, 0.1, 0], color1: 0xFF69B4, color2: 0xFFB6C1, stripes: 0, type: 2 },
                    { geometry: flamingoWing.clone(), offset: [-0.35, 0.1, 0], color1: 0xFF69B4, color2: 0xFFB6C1, stripes: 0, type: 2 },
                    { geometry: flamingoNeck, offset: [0, 0.15, 0], color1: 0xFF1493, color2: 0xFF69B4, stripes: 0, type: 6 },
                    { geometry: flamingoHead, offset: [0, 1.25, 0.4], color1: 0xFF1493, color2: 0xFF69B4, stripes: 0, type: 6 },
                    { geometry: flamingoBeak, offset: [0, 1.18, 0.58], color1: 0x333333, color2: 0xFFAA00, stripes: 0, type: 7 },
                    { geometry: flamingoTail, offset: [0, 0.15, -0.6], color1: 0xFF1493, color2: 0xFFB6C1, stripes: 0, type: 2 }
                ],
                position: new THREE.Vector3(-2.5, 0, 2.5),
                radius: 1.1,
                bobPhase: 3.0
            });

            // PALM TREE - base, trunk, leaves, coconut
            const palmBase = new THREE.TorusGeometry(0.75, 0.28, 16, 32);
            palmBase.rotateX(Math.PI / 2);

            // Palm trunk (tapered, segmented look)
            const palmTrunk = new THREE.CylinderGeometry(0.1, 0.16, 1.4, 12);

            // Palm leaves (multiple fronds)
            const createFrond = (angle) => {
                const frond = new THREE.ConeGeometry(0.12, 0.7, 4);
                frond.rotateX(Math.PI / 2 + 0.8);  // Tilt outward
                frond.rotateY(angle);
                frond.translate(Math.sin(angle) * 0.25, 0, Math.cos(angle) * 0.25);
                return frond;
            };

            // Create 6 fronds around the top
            const fronds = [];
            for (let i = 0; i < 6; i++) {
                fronds.push(createFrond(i * Math.PI / 3));
            }

            // Coconuts
            const coconut1 = new THREE.SphereGeometry(0.1, 8, 6);
            const coconut2 = new THREE.SphereGeometry(0.09, 8, 6);

            const palmParts = [
                { geometry: palmBase, offset: [0, 0, 0], color1: 0x4A90A4, color2: 0x5BA3B8, stripes: 0, type: 4 },
                { geometry: palmTrunk, offset: [0, 0.7, 0], color1: 0x8B4513, color2: 0xA0522D, stripes: 0, type: 5 },
                { geometry: coconut1, offset: [0.15, 1.2, 0.1], color1: 0x654321, color2: 0x8B4513, stripes: 0, type: 5 },
                { geometry: coconut2, offset: [-0.12, 1.15, -0.08], color1: 0x654321, color2: 0x8B4513, stripes: 0, type: 5 }
            ];

            // Add fronds
            fronds.forEach((frond, i) => {
                palmParts.push({
                    geometry: frond,
                    offset: [0, 1.4, 0],
                    color1: 0x228B22,
                    color2: 0x32CD32,
                    stripes: 0,
                    type: 4
                });
            });

            createToyGroup({
                parts: palmParts,
                position: new THREE.Vector3(3, 0, -2.5),
                radius: 1.0,
                bobPhase: 4.0
            });

            // Beach ball
            const ballGeo = new THREE.SphereGeometry(0.4, 24, 16);
            createToyGroup({
                parts: [{ geometry: ballGeo, offset: [0, 0.25, 0], color1: 0xFF4444, color2: 0xFFFFFF, stripes: 6, type: 1 }],
                position: new THREE.Vector3(-0.5, 0, 0.5),
                radius: 0.5,
                bobPhase: 0.5
            });
        }

        function createToyGroup(opts) {
            const group = {
                position: opts.position.clone(),
                radius: opts.radius,
                bobPhase: opts.bobPhase,
                driftSpeed: 0.008 + Math.random() * 0.012,
                driftDir: new THREE.Vector2(Math.random() - 0.5, Math.random() - 0.5).normalize(),
                rotSpeed: (Math.random() - 0.5) * 0.15,
                rotation: Math.random() * Math.PI * 2,
                meshes: []
            };

            opts.parts.forEach(part => {
                const mat = new THREE.ShaderMaterial({
                    uniforms: {
                        uTime: { value: 0 },
                        uToyPosition: { value: group.position },
                        uToyRotation: { value: group.rotation },
                        uPartOffset: { value: new THREE.Vector3(...part.offset) },
                        uToyColor: { value: new THREE.Color(part.color1) },
                        uToyColor2: { value: new THREE.Color(part.color2) },
                        uStripeCount: { value: part.stripes },
                        uToyScale: { value: 1.0 },
                        uToyType: { value: part.type },
                        uBobPhase: { value: opts.bobPhase },
                        ...createRippleUniforms()
                    },
                    vertexShader: toyVS,
                    fragmentShader: toyFS
                });

                const mesh = new THREE.Mesh(part.geometry, mat);
                group.meshes.push(mesh);
                toys.push(mesh);
                scene.add(mesh);
            });

            toyGroups.push(group);
        }

        function screenToWorld(x, y) {
            mouse.x = (x / window.innerWidth) * 2 - 1;
            mouse.y = -(y / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const pt = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, pt);
            return new THREE.Vector2(pt.x, pt.z);
        }

        function onMouseMove(e) {
            cursorEl.style.left = e.clientX + 'px';
            cursorEl.style.top = e.clientY + 'px';

            // Handle panning while right-click dragging
            if (isDragging) {
                const deltaX = (e.clientX - dragStart.x) * 0.02;
                const deltaY = (e.clientY - dragStart.y) * 0.02;
                cameraPanX -= deltaX;
                cameraPanZ -= deltaY;
                cameraPanX = Math.max(-10, Math.min(10, cameraPanX));
                cameraPanZ = Math.max(-12, Math.min(12, cameraPanZ));
                dragStart.set(e.clientX, e.clientY);
                updateCameraPOV(currentPOV);
                return;
            }

            const wp = screenToWorld(e.clientX, e.clientY);
            if (!wp) return;

            const now = performance.now();
            const dist = wp.distanceTo(lastMousePos);

            if (dist > 0.15 && now - lastRippleT > 25) {
                addRipple(wp.x, wp.y, isMouseDown ? CONFIG.rippleStrength * 1.5 : CONFIG.rippleStrength * 0.3);
                lastRippleT = now;
            }
            lastMousePos.copy(wp);
        }

        function onMouseDown(e) {
            // Right-click for panning
            if (e.button === 2) {
                isDragging = true;
                dragStart.set(e.clientX, e.clientY);
                return;
            }

            isMouseDown = true;
            cursorEl.classList.add('active');
            const wp = screenToWorld(e.clientX, e.clientY);
            if (wp) {
                addRipple(wp.x, wp.y, CONFIG.rippleStrength * 2);
                pushToys(wp);
            }
        }

        function onMouseUp(e) {
            if (e.button === 2) {
                isDragging = false;
                return;
            }
            isMouseDown = false;
            cursorEl.classList.remove('active');
        }

        function pushToys(wp) {
            toyGroups.forEach(group => {
                const pos = group.position;
                const dist = Math.sqrt((pos.x - wp.x) ** 2 + (pos.z - wp.y) ** 2);
                if (dist < 2.0 && dist > 0.1) {
                    const push = new THREE.Vector2(pos.x - wp.x, pos.z - wp.y).normalize();
                    group.driftDir.lerp(push, 0.5);
                    group.driftDir.normalize();
                    group.driftSpeed = Math.min(group.driftSpeed + 0.03, 0.05);
                    // Gentle spin from push
                    group.rotSpeed += (Math.random() - 0.5) * 0.1;
                }
            });
        }

        function onTouchStart(e) {
            // Allow touch events on UI controls
            if (e.target.closest('#pov-control, #audio-control, #weather-control')) {
                return;
            }
            e.preventDefault();
            const t = e.touches[0];
            cursorEl.style.left = t.clientX + 'px';
            cursorEl.style.top = t.clientY + 'px';
            cursorEl.classList.add('active');

            const wp = screenToWorld(t.clientX, t.clientY);
            if (wp) {
                addRipple(wp.x, wp.y, CONFIG.rippleStrength * 2);
                pushToys(wp);
                lastMousePos.copy(wp);
            }
        }

        function onTouchMove(e) {
            // Allow touch events on UI controls
            if (e.target.closest('#pov-control, #audio-control, #weather-control')) {
                return;
            }
            e.preventDefault();
            const t = e.touches[0];
            cursorEl.style.left = t.clientX + 'px';
            cursorEl.style.top = t.clientY + 'px';

            const wp = screenToWorld(t.clientX, t.clientY);
            if (!wp) return;

            const now = performance.now();
            if (wp.distanceTo(lastMousePos) > 0.12 && now - lastRippleT > 20) {
                addRipple(wp.x, wp.y, CONFIG.rippleStrength);
                lastRippleT = now;
            }
            lastMousePos.copy(wp);
        }

        function onTouchEnd() {
            cursorEl.classList.remove('active');
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateUniforms() {
            const data = getRippleData();

            // Reuse pre-allocated Vector2 arrays instead of creating new objects
            for (let i = 0; i < MAX_RIPPLES; i++) {
                ripplePositionsCache[i].set(data.positions[i * 2], data.positions[i * 2 + 1]);
                rippleParamsCache[i].set(data.params[i * 2], data.params[i * 2 + 1]);
            }

            floor.material.uniforms.uRipplePositions.value = ripplePositionsCache;
            floor.material.uniforms.uRippleParams.value = rippleParamsCache;
            water.material.uniforms.uRipplePositions.value = ripplePositionsCache;
            water.material.uniforms.uRippleParams.value = rippleParamsCache;

            toys.forEach(toy => {
                toy.material.uniforms.uRipplePositions.value = ripplePositionsCache;
                toy.material.uniforms.uRippleParams.value = rippleParamsCache;
            });
        }

        function updateToys(dt, elapsed) {
            // Update toy groups (compound toys)
            toyGroups.forEach(group => {
                // Apply drift
                group.position.x += group.driftDir.x * group.driftSpeed * dt * 60;
                group.position.z += group.driftDir.y * group.driftSpeed * dt * 60;

                // Slow down
                group.driftSpeed *= 0.995;
                if (group.driftSpeed < 0.005) group.driftSpeed = 0.005;

                // Bounce off edges - keep toys well within pool water
                const boundsX = 5.5;
                const boundsZ = 7.5;
                if (Math.abs(group.position.x) > boundsX) {
                    group.driftDir.x *= -0.5;
                    group.position.x = Math.sign(group.position.x) * boundsX;
                    group.driftSpeed *= 0.7;
                }
                if (Math.abs(group.position.z) > boundsZ) {
                    group.driftDir.y *= -0.5;
                    group.position.z = Math.sign(group.position.z) * boundsZ;
                    group.driftSpeed *= 0.7;
                }

                // Rotate
                group.rotation += group.rotSpeed * dt;

                // Update all meshes in group
                group.meshes.forEach(mesh => {
                    mesh.material.uniforms.uToyRotation.value = group.rotation;
                    mesh.material.uniforms.uTime.value = elapsed;
                });
            });

            // Collision detection between toy groups - gentle bumping
            for (let i = 0; i < toyGroups.length; i++) {
                for (let j = i + 1; j < toyGroups.length; j++) {
                    const a = toyGroups[i];
                    const b = toyGroups[j];

                    const dx = b.position.x - a.position.x;
                    const dz = b.position.z - a.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    const minDist = a.radius + b.radius;

                    if (dist < minDist && dist > 0.01) {
                        // Collision! Gently push apart
                        const overlap = minDist - dist;
                        const nx = dx / dist;
                        const nz = dz / dist;

                        // Soft separation
                        const pushStrength = overlap * 0.3;
                        a.position.x -= nx * pushStrength;
                        a.position.z -= nz * pushStrength;
                        b.position.x += nx * pushStrength;
                        b.position.z += nz * pushStrength;

                        // Gentle bounce - exchange direction slightly
                        const bounce = 0.15;
                        a.driftDir.x -= nx * bounce;
                        a.driftDir.y -= nz * bounce;
                        b.driftDir.x += nx * bounce;
                        b.driftDir.y += nz * bounce;

                        a.driftDir.normalize();
                        b.driftDir.normalize();

                        // Lose energy on collision (dampen, don't amplify)
                        a.driftSpeed *= 0.85;
                        b.driftSpeed *= 0.85;

                        // Tiny spin from collision
                        a.rotSpeed += (Math.random() - 0.5) * 0.05;
                        b.rotSpeed += (Math.random() - 0.5) * 0.05;
                    }
                }
            }

            // Cap speeds and dampen spin
            toyGroups.forEach(group => {
                group.driftSpeed = Math.min(group.driftSpeed, 0.06);
                group.rotSpeed *= 0.98;
                group.rotSpeed = Math.max(-0.3, Math.min(0.3, group.rotSpeed));
            });

            // Also update ripple uniforms for all toy meshes
            toys.forEach(toy => {
                // Ripple uniforms are updated in updateUniforms()
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            const dt = Math.min(clock.getDelta(), 0.1);
            const elapsed = clock.getElapsedTime() * CONFIG.waveSpeed;

            updateRipples(dt);
            updateUniforms();
            updateToys(dt, elapsed);
            updateRain();

            floor.material.uniforms.uTime.value = elapsed;
            water.material.uniforms.uTime.value = elapsed;

            // Animate waterfall
            if (window.waterfallMesh) {
                window.waterfallMesh.material.uniforms.uTime.value = elapsed;
            }

            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>
